CCS PCM C Compiler, Version 4.114, 93460303               18-ene-17 19:28

               Filename: C:\Users\Nico\Documents\carpetas\Programa para glcd\programa para glcd.lst

               ROM used: 5336 words (65%)
                         Largest free fragment is 2048
               RAM used: 128 (35%) at main() level
                         161 (44%) worst case
               Stack:    6 locations

*
0000:  MOVLW  12
0001:  MOVWF  0A
0002:  GOTO   2A4
0003:  NOP
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                Programa para tocuh y GLCD                       //// 
.................... //// -c0 touch -c1 tocuh An0- canal analogico 1  y An1 otra          //// 
.................... //// -c3 prendido apagado de ampli                                   //// 
.................... //// -c4 volumen mas                                                 //// 
.................... //// -c5 volumen menos                                               //// 
.................... //// -c6 transmisor rs232 para luz                                   //// 
.................... //// 13-Osc                                                          //// 
.................... //// 14-Osc                                                          //// 
.................... ////     A2 A4 A5 salida para rf con E0                              //// 
.................... ////     0000 nada       0011 late2   0110prender1001vol+   1100       1111      /// 
.................... ////     0001 late1      0100 presno  1010apgar  1101                //// 
.................... ////     0010 centro     0101 pressi  1011vol-   1110                //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //Configuracion de includes                                             / 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <16f877a.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #device ADC=10; 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
12BE:  BCF    03.5
12BF:  CLRF   20
12C0:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
....................  
.................... #include <STRING.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #use delay (clock=4000000) 
*
070C:  MOVLW  C0
070D:  MOVWF  04
070E:  BCF    03.7
070F:  MOVF   00,W
0710:  BTFSC  03.2
0711:  GOTO   720
0712:  MOVLW  01
0713:  MOVWF  78
0714:  CLRF   77
0715:  DECFSZ 77,F
0716:  GOTO   715
0717:  DECFSZ 78,F
0718:  GOTO   714
0719:  MOVLW  4A
071A:  MOVWF  77
071B:  DECFSZ 77,F
071C:  GOTO   71B
071D:  GOTO   71E
071E:  DECFSZ 00,F
071F:  GOTO   712
0720:  RETURN
.................... #use rs232 (baud=2400,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #include <C:\Users\Nico\Documents\carpetas\Programa para glcd\GLCDNICO.TXT> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with //// 
.................... //// an LED backlight. The HDM64GS12 is 128 pixles across and 64     //// 
.................... //// pixels down. The driver treats the upper left pixel as (0,0).   //// 
.................... ////                                                                 //// 
.................... //// LCD Pin connections:                                            //// 
.................... //// (These can be changed as needed in the following defines).      //// 
.................... ////  * 1: VSS is connected to GND                                   //// 
.................... ////  * 2: VDD is connected to +5V                                   //// 
.................... ////  * 3: V0 - LCD operating voltage is connected from a 20k Ohm POT//// 
.................... ////  * 4: D/I - Data or Instruction is connected to B2              //// 
.................... ////  * 5: R/W - Read or Write is connected to B4                    //// 
.................... ////  * 6: Enable is connected to B5                                 //// 
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  //// 
.................... ////  *15: Chip Select 1 is connected to B0                          //// 
.................... ////  *16: Chip Select 2 is connected to B1                          //// 
.................... ////  *17: Reset is connected to C2                                  //// 
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     //// 
.................... ////  *19: Positive voltage for LED backlight is connected to +5V to B3// 
.................... ////  *20: Negavtive voltage for LED backlight is connected to GND   //// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////     * Must be called before any other function.                 //// 
.................... ////       - mode can be ON or OFF to turn the LCD on or off         //// 
.................... ////                                                                 //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////     * Sets the pixel to the given color.                        //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_line(x1,y1,x2,y2,color)                                   //// 
.................... ////     * Draws a line from the first point to the second point     //// 
.................... ////       with the given color.                                     //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_rect(x1,y1,x2,y2,fill,color)                              //// 
.................... ////     * Draws a rectangle with upper left point (x1,y1) and lower //// 
.................... ////       right point (x2,y2).                                      //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_bar(x1,y1,x2,y2,width,color)                              //// 
.................... ////     * Draws a bar (wide line) from the first point to the       //// 
.................... ////       second point.                                             //// 
.................... ////       - width is the number of pixels wide                      //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_circle(x,y,radius,fill,color)                             //// 
.................... ////     * Draws a circle with center at (x,y)                       //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_text57(x,y,textptr,size,color)                            //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y).//// 
.................... ////       Characters are 5 pixels wide and 7 pixels tall.           //// 
.................... ////       - size is an integer that scales the size of the text     //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////     * Note - The given text is character wrapped. If this       //// 
.................... ////       function is used on a different size display, then change //// 
.................... ////       the GLCD_WIDTH define appropriately.                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////     * Fills the entire LCD with the given color.                //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #ifndef GLCD_C 
.................... #define GLCD_C 
....................  
.................... #ifndef GLCD_WIDTH 
.................... #define GLCD_WIDTH 128    // Used for text wrapping by glcd_text57 function 
.................... #endif 
....................  
.................... #define ON  1 
.................... #define OFF 0 
....................  
.................... #define YES 1 
.................... #define NO  0 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1 PIN_B0   // Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2 PIN_B1   // Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_DI 
.................... #define GLCD_DI  PIN_B2   // Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW  PIN_B4   // Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E   PIN_B5   // Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST PIN_C2   // Reset 
.................... #endif 
....................  
....................  
....................  
.................... BYTE glcd_readByte(BYTE chip); 
.................... void glcd_writeByte(BYTE chip, BYTE data); 
.................... void glcd_fillScreen(int1 color); 
.................... void invertir(int x1, int y1, int x2, int y2); 
.................... void dibujo(char *a); 
.................... void incrementar(int a); 
.................... void incrementar2(int a); 
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
....................  
.................... // Purpose:       Initialize a graphic LCD. This must be called before any 
.................... //                other glcd function is used. 
.................... // Inputs:        The initialization mode 
.................... //                OFF - Turns the LCD off 
.................... //                ON  - Turns the LCD on 
.................... // Date:          5/28/2003 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
*
06A6:  BCF    22.2
06A7:  MOVF   22,W
06A8:  BSF    03.5
06A9:  MOVWF  07
06AA:  BCF    03.5
06AB:  BSF    07.2
....................    output_low(GLCD_E); 
06AC:  BSF    03.5
06AD:  BCF    06.5
06AE:  BCF    03.5
06AF:  BCF    06.5
....................    output_HIGH(GLCD_CS1); 
06B0:  BSF    03.5
06B1:  BCF    06.0
06B2:  BCF    03.5
06B3:  BSF    06.0
....................    output_HIGH(GLCD_CS2); 
06B4:  BSF    03.5
06B5:  BCF    06.1
06B6:  BCF    03.5
06B7:  BSF    06.1
....................  
....................    output_low(GLCD_DI);                // Set for instruction 
06B8:  BSF    03.5
06B9:  BCF    06.2
06BA:  BCF    03.5
06BB:  BCF    06.2
....................    glcd_writeByte(GLCD_CS1, 0xC0);     // Specify first RAM line at the top 
06BC:  MOVLW  30
06BD:  BSF    03.5
06BE:  MOVWF  5F
06BF:  MOVLW  C0
06C0:  MOVWF  60
06C1:  BCF    03.5
06C2:  CALL   5FC
....................    glcd_writeByte(GLCD_CS2, 0xC0);     //   of the screen 
06C3:  MOVLW  31
06C4:  BSF    03.5
06C5:  MOVWF  5F
06C6:  MOVLW  C0
06C7:  MOVWF  60
06C8:  BCF    03.5
06C9:  CALL   5FC
....................    glcd_writeByte(GLCD_CS1, 0x40);     // Set the column address to 0 
06CA:  MOVLW  30
06CB:  BSF    03.5
06CC:  MOVWF  5F
06CD:  MOVLW  40
06CE:  MOVWF  60
06CF:  BCF    03.5
06D0:  CALL   5FC
....................    glcd_writeByte(GLCD_CS2, 0x40); 
06D1:  MOVLW  31
06D2:  BSF    03.5
06D3:  MOVWF  5F
06D4:  MOVLW  40
06D5:  MOVWF  60
06D6:  BCF    03.5
06D7:  CALL   5FC
....................    glcd_writeByte(GLCD_CS1, 0xB8);     // Set the page address to 0 
06D8:  MOVLW  30
06D9:  BSF    03.5
06DA:  MOVWF  5F
06DB:  MOVLW  B8
06DC:  MOVWF  60
06DD:  BCF    03.5
06DE:  CALL   5FC
....................    glcd_writeByte(GLCD_CS2, 0xB8); 
06DF:  MOVLW  31
06E0:  BSF    03.5
06E1:  MOVWF  5F
06E2:  MOVLW  B8
06E3:  MOVWF  60
06E4:  BCF    03.5
06E5:  CALL   5FC
....................    if(mode == ON) 
06E6:  BSF    03.5
06E7:  DECFSZ 3F,W
06E8:  GOTO   6F8
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3F);  // Turn the display on 
06E9:  MOVLW  30
06EA:  MOVWF  5F
06EB:  MOVLW  3F
06EC:  MOVWF  60
06ED:  BCF    03.5
06EE:  CALL   5FC
....................       glcd_writeByte(GLCD_CS2, 0x3F); 
06EF:  MOVLW  31
06F0:  BSF    03.5
06F1:  MOVWF  5F
06F2:  MOVLW  3F
06F3:  MOVWF  60
06F4:  BCF    03.5
06F5:  CALL   5FC
....................    } 
....................    else 
06F6:  GOTO   705
06F7:  BSF    03.5
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3E);  // Turn the display off 
06F8:  MOVLW  30
06F9:  MOVWF  5F
06FA:  MOVLW  3E
06FB:  MOVWF  60
06FC:  BCF    03.5
06FD:  CALL   5FC
....................       glcd_writeByte(GLCD_CS2, 0x3E); 
06FE:  MOVLW  31
06FF:  BSF    03.5
0700:  MOVWF  5F
0701:  MOVLW  3E
0702:  MOVWF  60
0703:  BCF    03.5
0704:  CALL   5FC
....................    } 
....................  
....................    glcd_fillScreen(OFF);               // Clear the display 
0705:  BSF    03.5
0706:  CLRF   40
0707:  BCF    03.5
0708:  CALL   64B
.................... } 
0709:  BCF    0A.3
070A:  BSF    0A.4
070B:  GOTO   3A7 (RETURN)
....................  
....................  
.................... // Purpose:       Turn a pixel on a graphic LCD on or off 
.................... // Inputs:        x - the x coordinate of the pixel 
.................... //                y - the y coordinate of the pixel 
.................... //                color - ON or OFF 
.................... // Output:        1 if coordinate out of range, 0 if in range 
.................... void glcd_pixel(int x, int y, int1 color) 
.................... { 
*
075F:  MOVLW  30
0760:  BSF    03.5
0761:  MOVWF  5D
....................    BYTE data; 
....................    BYTE chip = GLCD_CS1;  // Stores which chip to use on the LCD 
....................  
....................    if(x > 63)  // Check for first or second display area 
0762:  MOVF   59,W
0763:  SUBLW  3F
0764:  BTFSC  03.0
0765:  GOTO   76A
....................    { 
....................       x -= 64; 
0766:  MOVLW  40
0767:  SUBWF  59,F
....................       chip = GLCD_CS2; 
0768:  MOVLW  31
0769:  MOVWF  5D
....................    } 
....................  
....................    output_low(GLCD_DI);                                     // Set for instruction 
076A:  BCF    06.2
076B:  BCF    03.5
076C:  BCF    06.2
....................    bit_clear(x,7);                                          // Clear the MSB. Part of an instruction code 
076D:  BSF    03.5
076E:  BCF    59.7
....................    bit_set(x,6);                                            // Set bit 6. Also part of an instruction code 
076F:  BSF    59.6
....................    glcd_writeByte(chip, x);                                 // Set the horizontal address 
0770:  MOVF   5D,W
0771:  MOVWF  5F
0772:  MOVF   59,W
0773:  MOVWF  60
0774:  BCF    03.5
0775:  CALL   5FC
....................    glcd_writeByte(chip, (y/8 & 0b10111111) | 0b10111000);   // Set the vertical page address 
0776:  BSF    03.5
0777:  RRF    5A,W
0778:  MOVWF  77
0779:  RRF    77,F
077A:  RRF    77,F
077B:  MOVLW  1F
077C:  ANDWF  77,F
077D:  MOVF   77,W
077E:  ANDLW  BF
077F:  IORLW  B8
0780:  MOVWF  5E
0781:  MOVF   5D,W
0782:  MOVWF  5F
0783:  MOVF   5E,W
0784:  MOVWF  60
0785:  BCF    03.5
0786:  CALL   5FC
....................    output_high(GLCD_DI);                                    // Set for data 
0787:  BSF    03.5
0788:  BCF    06.2
0789:  BCF    03.5
078A:  BSF    06.2
....................    data = glcd_readByte(chip); 
078B:  BSF    03.5
078C:  MOVF   5D,W
078D:  MOVWF  5E
*
07C4:  MOVF   78,W
07C5:  MOVWF  5C
....................  
....................    if(color == ON) 
07C6:  DECFSZ 5B,W
07C7:  GOTO   7D8
....................       bit_set(data, y%8);        // Turn the pixel on 
07C8:  MOVF   5A,W
07C9:  ANDLW  07
07CA:  MOVWF  5E
07CB:  MOVLW  01
07CC:  MOVWF  77
07CD:  MOVF   5E,W
07CE:  MOVWF  78
07CF:  BTFSC  03.2
07D0:  GOTO   7D5
07D1:  BCF    03.0
07D2:  RLF    77,F
07D3:  DECFSZ 78,F
07D4:  GOTO   7D1
07D5:  MOVF   77,W
07D6:  IORWF  5C,F
....................    else                          // or 
07D7:  GOTO   7E8
....................       bit_clear(data, y%8);      // turn the pixel off 
07D8:  MOVF   5A,W
07D9:  ANDLW  07
07DA:  MOVWF  5E
07DB:  MOVLW  01
07DC:  MOVWF  77
07DD:  MOVF   5E,W
07DE:  MOVWF  78
07DF:  BTFSC  03.2
07E0:  GOTO   7E5
07E1:  BCF    03.0
07E2:  RLF    77,F
07E3:  DECFSZ 78,F
07E4:  GOTO   7E1
07E5:  MOVF   77,W
07E6:  XORLW  FF
07E7:  ANDWF  5C,F
....................    output_low(GLCD_DI);          // Set for instruction 
07E8:  BCF    06.2
07E9:  BCF    03.5
07EA:  BCF    06.2
....................    glcd_writeByte(chip, x);      // Set the horizontal address 
07EB:  BSF    03.5
07EC:  MOVF   5D,W
07ED:  MOVWF  5F
07EE:  MOVF   59,W
07EF:  MOVWF  60
07F0:  BCF    03.5
07F1:  CALL   5FC
....................    output_high(GLCD_DI);         // Set for data 
07F2:  BSF    03.5
07F3:  BCF    06.2
07F4:  BCF    03.5
07F5:  BSF    06.2
....................    glcd_writeByte(chip, data);   // Write the pixel data 
07F6:  BSF    03.5
07F7:  MOVF   5D,W
07F8:  MOVWF  5F
07F9:  MOVF   5C,W
07FA:  MOVWF  60
07FB:  BCF    03.5
07FC:  CALL   5FC
.................... } 
07FD:  RETURN
....................  
....................  
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's 
.................... //                line drawing algorithm 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel() 
.................... void glcd_line(int x1, int y1, int x2, int y2, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, dx, dy; 
....................    signed long P; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
*
08E9:  BSF    03.5
08EA:  MOVF   4B,W
08EB:  SUBWF  4D,W
08EC:  MOVWF  59
08ED:  MOVF   59,W
08EE:  BTFSS  59.7
08EF:  GOTO   0F2
08F0:  MOVF   59,W
08F1:  SUBLW  00
08F2:  MOVWF  54
....................    dy = abs((signed int)(y2 - y1)); 
08F3:  MOVF   4C,W
08F4:  SUBWF  4E,W
08F5:  MOVWF  59
08F6:  MOVF   59,W
08F7:  BTFSS  59.7
08F8:  GOTO   0FB
08F9:  MOVF   59,W
08FA:  SUBLW  00
08FB:  MOVWF  55
....................    x = x1; 
08FC:  MOVF   4B,W
08FD:  MOVWF  50
....................    y = y1; 
08FE:  MOVF   4C,W
08FF:  MOVWF  51
....................  
....................    if(x1 > x2) 
0900:  MOVF   4B,W
0901:  SUBWF  4D,W
0902:  BTFSC  03.0
0903:  GOTO   107
....................       addx = -1; 
0904:  MOVLW  FF
0905:  MOVWF  52
....................    else 
0906:  GOTO   109
....................       addx = 1; 
0907:  MOVLW  01
0908:  MOVWF  52
....................    if(y1 > y2) 
0909:  MOVF   4C,W
090A:  SUBWF  4E,W
090B:  BTFSC  03.0
090C:  GOTO   110
....................       addy = -1; 
090D:  MOVLW  FF
090E:  MOVWF  53
....................    else 
090F:  GOTO   112
....................       addy = 1; 
0910:  MOVLW  01
0911:  MOVWF  53
....................  
....................    if(dx >= dy) 
0912:  MOVF   55,W
0913:  XORLW  80
0914:  MOVWF  77
0915:  MOVF   54,W
0916:  XORLW  80
0917:  SUBWF  77,W
0918:  BTFSC  03.2
0919:  GOTO   11C
091A:  BTFSC  03.0
091B:  GOTO   17E
....................    { 
....................       P = 2*dy - dx; 
091C:  MOVLW  02
091D:  MOVWF  5A
091E:  MOVF   55,W
091F:  MOVWF  5B
0920:  BCF    0A.3
0921:  BCF    03.5
0922:  CALL   624
0923:  BSF    0A.3
0924:  BSF    03.5
0925:  MOVF   54,W
0926:  SUBWF  78,W
0927:  CLRF   7A
0928:  MOVWF  77
0929:  BTFSC  77.7
092A:  DECF   7A,F
092B:  MOVWF  56
092C:  MOVF   7A,W
092D:  MOVWF  57
....................  
....................       for(i=0; i<=dx; ++i) 
092E:  CLRF   58
092F:  BTFSC  54.7
0930:  GOTO   17D
0931:  MOVF   58,W
0932:  SUBWF  54,W
0933:  BTFSS  03.0
0934:  GOTO   17D
....................       { 
....................          glcd_pixel(x, y, color); 
0935:  MOVF   50,W
0936:  MOVWF  59
0937:  MOVF   51,W
0938:  MOVWF  5A
0939:  MOVF   4F,W
093A:  MOVWF  5B
093B:  BCF    0A.3
093C:  BCF    03.5
093D:  CALL   75F
093E:  BSF    0A.3
....................  
....................          if(P < 0) 
093F:  BSF    03.5
0940:  BTFSS  57.7
0941:  GOTO   158
....................          { 
....................             P += 2*dy; 
0942:  MOVLW  02
0943:  MOVWF  5A
0944:  MOVF   55,W
0945:  MOVWF  5B
0946:  BCF    0A.3
0947:  BCF    03.5
0948:  CALL   624
0949:  BSF    0A.3
094A:  MOVF   78,W
094B:  CLRF   7A
094C:  MOVWF  77
094D:  BTFSC  77.7
094E:  DECF   7A,F
094F:  BSF    03.5
0950:  ADDWF  56,F
0951:  MOVF   7A,W
0952:  BTFSC  03.0
0953:  INCFSZ 7A,W
0954:  ADDWF  57,F
....................             x += addx; 
0955:  MOVF   52,W
0956:  ADDWF  50,F
....................          } 
....................          else 
0957:  GOTO   17B
....................          { 
....................             P += 2*dy - 2*dx; 
0958:  MOVLW  02
0959:  MOVWF  5A
095A:  MOVF   55,W
095B:  MOVWF  5B
095C:  BCF    0A.3
095D:  BCF    03.5
095E:  CALL   624
095F:  BSF    0A.3
0960:  MOVF   78,W
0961:  BSF    03.5
0962:  MOVWF  59
0963:  MOVLW  02
0964:  MOVWF  5A
0965:  MOVF   54,W
0966:  MOVWF  5B
0967:  BCF    0A.3
0968:  BCF    03.5
0969:  CALL   624
096A:  BSF    0A.3
096B:  MOVF   78,W
096C:  BSF    03.5
096D:  SUBWF  59,W
096E:  CLRF   7A
096F:  MOVWF  77
0970:  BTFSC  77.7
0971:  DECF   7A,F
0972:  ADDWF  56,F
0973:  MOVF   7A,W
0974:  BTFSC  03.0
0975:  INCFSZ 7A,W
0976:  ADDWF  57,F
....................             x += addx; 
0977:  MOVF   52,W
0978:  ADDWF  50,F
....................             y += addy; 
0979:  MOVF   53,W
097A:  ADDWF  51,F
....................          } 
....................       } 
097B:  INCF   58,F
097C:  GOTO   12F
....................    } 
....................    else 
097D:  GOTO   1DF
....................    { 
....................       P = 2*dx - dy; 
097E:  MOVLW  02
097F:  MOVWF  5A
0980:  MOVF   54,W
0981:  MOVWF  5B
0982:  BCF    0A.3
0983:  BCF    03.5
0984:  CALL   624
0985:  BSF    0A.3
0986:  BSF    03.5
0987:  MOVF   55,W
0988:  SUBWF  78,W
0989:  CLRF   7A
098A:  MOVWF  77
098B:  BTFSC  77.7
098C:  DECF   7A,F
098D:  MOVWF  56
098E:  MOVF   7A,W
098F:  MOVWF  57
....................  
....................       for(i=0; i<=dy; ++i) 
0990:  CLRF   58
0991:  BTFSC  55.7
0992:  GOTO   1DF
0993:  MOVF   58,W
0994:  SUBWF  55,W
0995:  BTFSS  03.0
0996:  GOTO   1DF
....................       { 
....................          glcd_pixel(x, y, color); 
0997:  MOVF   50,W
0998:  MOVWF  59
0999:  MOVF   51,W
099A:  MOVWF  5A
099B:  MOVF   4F,W
099C:  MOVWF  5B
099D:  BCF    0A.3
099E:  BCF    03.5
099F:  CALL   75F
09A0:  BSF    0A.3
....................  
....................          if(P < 0) 
09A1:  BSF    03.5
09A2:  BTFSS  57.7
09A3:  GOTO   1BA
....................          { 
....................             P += 2*dx; 
09A4:  MOVLW  02
09A5:  MOVWF  5A
09A6:  MOVF   54,W
09A7:  MOVWF  5B
09A8:  BCF    0A.3
09A9:  BCF    03.5
09AA:  CALL   624
09AB:  BSF    0A.3
09AC:  MOVF   78,W
09AD:  CLRF   7A
09AE:  MOVWF  77
09AF:  BTFSC  77.7
09B0:  DECF   7A,F
09B1:  BSF    03.5
09B2:  ADDWF  56,F
09B3:  MOVF   7A,W
09B4:  BTFSC  03.0
09B5:  INCFSZ 7A,W
09B6:  ADDWF  57,F
....................             y += addy; 
09B7:  MOVF   53,W
09B8:  ADDWF  51,F
....................          } 
....................          else 
09B9:  GOTO   1DD
....................          { 
....................             P += 2*dx - 2*dy; 
09BA:  MOVLW  02
09BB:  MOVWF  5A
09BC:  MOVF   54,W
09BD:  MOVWF  5B
09BE:  BCF    0A.3
09BF:  BCF    03.5
09C0:  CALL   624
09C1:  BSF    0A.3
09C2:  MOVF   78,W
09C3:  BSF    03.5
09C4:  MOVWF  59
09C5:  MOVLW  02
09C6:  MOVWF  5A
09C7:  MOVF   55,W
09C8:  MOVWF  5B
09C9:  BCF    0A.3
09CA:  BCF    03.5
09CB:  CALL   624
09CC:  BSF    0A.3
09CD:  MOVF   78,W
09CE:  BSF    03.5
09CF:  SUBWF  59,W
09D0:  CLRF   7A
09D1:  MOVWF  77
09D2:  BTFSC  77.7
09D3:  DECF   7A,F
09D4:  ADDWF  56,F
09D5:  MOVF   7A,W
09D6:  BTFSC  03.0
09D7:  INCFSZ 7A,W
09D8:  ADDWF  57,F
....................             x += addx; 
09D9:  MOVF   52,W
09DA:  ADDWF  50,F
....................             y += addy; 
09DB:  MOVF   53,W
09DC:  ADDWF  51,F
....................          } 
....................       } 
09DD:  INCF   58,F
09DE:  GOTO   191
....................    } 
.................... } 
09DF:  BCF    03.5
09E0:  RETURN
....................  
....................  
.................... // Purpose:       Draw a rectangle on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                fill  - YES or NO 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel(), glcd_line() 
.................... void glcd_rect(int x1, int y1, int x2, int y2, int fill, int1 color) 
.................... { 
....................    if(fill) 
09E1:  BSF    03.5
09E2:  MOVF   43,F
09E3:  BTFSC  03.2
09E4:  GOTO   206
....................    { 
....................       int y, ymax;                          // Find the y min and max 
....................       if(y1 < y2) 
09E5:  MOVF   42,W
09E6:  SUBWF  40,W
09E7:  BTFSC  03.0
09E8:  GOTO   1EE
....................       { 
....................          y = y1; 
09E9:  MOVF   40,W
09EA:  MOVWF  45
....................          ymax = y2; 
09EB:  MOVF   42,W
09EC:  MOVWF  46
....................       } 
....................       else 
09ED:  GOTO   1F2
....................       { 
....................          y = y2; 
09EE:  MOVF   42,W
09EF:  MOVWF  45
....................          ymax = y1; 
09F0:  MOVF   40,W
09F1:  MOVWF  46
....................       } 
....................  
....................       for(; y<=ymax; ++y)                    // Draw lines to fill the rectangle 
09F2:  MOVF   45,W
09F3:  SUBWF  46,W
09F4:  BTFSS  03.0
09F5:  GOTO   205
....................          glcd_line(x1, y, x2, y, color); 
09F6:  MOVF   3F,W
09F7:  MOVWF  4B
09F8:  MOVF   45,W
09F9:  MOVWF  4C
09FA:  MOVF   41,W
09FB:  MOVWF  4D
09FC:  MOVF   45,W
09FD:  MOVWF  4E
09FE:  MOVF   44,W
09FF:  MOVWF  4F
0A00:  BCF    03.5
0A01:  CALL   0E9
0A02:  BSF    03.5
0A03:  INCF   45,F
0A04:  GOTO   1F2
....................    } 
....................    else 
0A05:  GOTO   23A
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
0A06:  MOVF   3F,W
0A07:  MOVWF  4B
0A08:  MOVF   40,W
0A09:  MOVWF  4C
0A0A:  MOVF   41,W
0A0B:  MOVWF  4D
0A0C:  MOVF   40,W
0A0D:  MOVWF  4E
0A0E:  MOVF   44,W
0A0F:  MOVWF  4F
0A10:  BCF    03.5
0A11:  CALL   0E9
....................       glcd_line(x1, y2, x2, y2, color); 
0A12:  BSF    03.5
0A13:  MOVF   3F,W
0A14:  MOVWF  4B
0A15:  MOVF   42,W
0A16:  MOVWF  4C
0A17:  MOVF   41,W
0A18:  MOVWF  4D
0A19:  MOVF   42,W
0A1A:  MOVWF  4E
0A1B:  MOVF   44,W
0A1C:  MOVWF  4F
0A1D:  BCF    03.5
0A1E:  CALL   0E9
....................       glcd_line(x1, y1, x1, y2, color); 
0A1F:  BSF    03.5
0A20:  MOVF   3F,W
0A21:  MOVWF  4B
0A22:  MOVF   40,W
0A23:  MOVWF  4C
0A24:  MOVF   3F,W
0A25:  MOVWF  4D
0A26:  MOVF   42,W
0A27:  MOVWF  4E
0A28:  MOVF   44,W
0A29:  MOVWF  4F
0A2A:  BCF    03.5
0A2B:  CALL   0E9
....................       glcd_line(x2, y1, x2, y2, color); 
0A2C:  BSF    03.5
0A2D:  MOVF   41,W
0A2E:  MOVWF  4B
0A2F:  MOVF   40,W
0A30:  MOVWF  4C
0A31:  MOVF   41,W
0A32:  MOVWF  4D
0A33:  MOVF   42,W
0A34:  MOVWF  4E
0A35:  MOVF   44,W
0A36:  MOVWF  4F
0A37:  BCF    03.5
0A38:  CALL   0E9
0A39:  BSF    03.5
....................    } 
.................... } 
0A3A:  BCF    03.5
0A3B:  RETURN
....................  
....................  
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                width  - The number of pixels wide 
.................... //                color - ON or OFF 
.................... void glcd_bar(int x1, int y1, int x2, int y2, int width, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, j; 
....................    signed long P, dx, dy, c1, c2; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
....................    dy = abs((signed int)(y2 - y1)); 
....................    x = x1; 
....................    y = y1; 
....................    c1 = -dx*x1 - dy*y1; 
....................    c2 = -dx*x2 - dy*y2; 
....................  
....................    if(x1 > x2) 
....................    { 
....................       addx = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addx = 1; 
....................    if(y1 > y2) 
....................    { 
....................       addy = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addy = 1; 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x, y+j, color); 
....................          } 
....................          if(P < 0) 
....................          { 
....................             P += 2*dy; 
....................             x += addx; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          if(P < 0) 
....................          { 
....................             P += 2*dx; 
....................             y += addy; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x+j, y, color); 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a circle on a graphic LCD 
.................... // Inputs:        (x,y) - the center of the circle 
.................... //                radius - the radius of the circle 
.................... //                fill - YES or NO 
.................... //                color - ON or OFF 
.................... void glcd_circle(int x, int y, int radius, int1 fill, int1 color) 
.................... { 
....................    signed int a, b, P; 
....................    a = 0; 
*
0BD6:  BSF    03.5
0BD7:  CLRF   44
....................    b = radius; 
0BD8:  MOVF   41,W
0BD9:  MOVWF  45
....................    P = 1 - radius; 
0BDA:  MOVF   41,W
0BDB:  SUBLW  01
0BDC:  MOVWF  46
....................  
....................    do 
....................    { 
....................       if(fill) 
0BDD:  MOVF   42,F
0BDE:  BTFSC  03.2
0BDF:  GOTO   445
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
0BE0:  MOVF   44,W
0BE1:  SUBWF  3F,W
0BE2:  MOVWF  47
0BE3:  MOVF   45,W
0BE4:  ADDWF  40,W
0BE5:  MOVWF  48
0BE6:  MOVF   44,W
0BE7:  ADDWF  3F,W
0BE8:  MOVWF  49
0BE9:  MOVF   45,W
0BEA:  ADDWF  40,W
0BEB:  MOVWF  4A
0BEC:  MOVF   47,W
0BED:  MOVWF  4B
0BEE:  MOVF   48,W
0BEF:  MOVWF  4C
0BF0:  MOVF   49,W
0BF1:  MOVWF  4D
0BF2:  MOVF   4A,W
0BF3:  MOVWF  4E
0BF4:  MOVF   43,W
0BF5:  MOVWF  4F
0BF6:  BCF    03.5
0BF7:  CALL   0E9
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
0BF8:  BSF    03.5
0BF9:  MOVF   44,W
0BFA:  SUBWF  3F,W
0BFB:  MOVWF  47
0BFC:  MOVF   45,W
0BFD:  SUBWF  40,W
0BFE:  MOVWF  48
0BFF:  MOVF   44,W
0C00:  ADDWF  3F,W
0C01:  MOVWF  49
0C02:  MOVF   45,W
0C03:  SUBWF  40,W
0C04:  MOVWF  4A
0C05:  MOVF   47,W
0C06:  MOVWF  4B
0C07:  MOVF   48,W
0C08:  MOVWF  4C
0C09:  MOVF   49,W
0C0A:  MOVWF  4D
0C0B:  MOVF   4A,W
0C0C:  MOVWF  4E
0C0D:  MOVF   43,W
0C0E:  MOVWF  4F
0C0F:  BCF    03.5
0C10:  CALL   0E9
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
0C11:  BSF    03.5
0C12:  MOVF   45,W
0C13:  SUBWF  3F,W
0C14:  MOVWF  47
0C15:  MOVF   44,W
0C16:  ADDWF  40,W
0C17:  MOVWF  48
0C18:  MOVF   45,W
0C19:  ADDWF  3F,W
0C1A:  MOVWF  49
0C1B:  MOVF   44,W
0C1C:  ADDWF  40,W
0C1D:  MOVWF  4A
0C1E:  MOVF   47,W
0C1F:  MOVWF  4B
0C20:  MOVF   48,W
0C21:  MOVWF  4C
0C22:  MOVF   49,W
0C23:  MOVWF  4D
0C24:  MOVF   4A,W
0C25:  MOVWF  4E
0C26:  MOVF   43,W
0C27:  MOVWF  4F
0C28:  BCF    03.5
0C29:  CALL   0E9
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
0C2A:  BSF    03.5
0C2B:  MOVF   45,W
0C2C:  SUBWF  3F,W
0C2D:  MOVWF  47
0C2E:  MOVF   44,W
0C2F:  SUBWF  40,W
0C30:  MOVWF  48
0C31:  MOVF   45,W
0C32:  ADDWF  3F,W
0C33:  MOVWF  49
0C34:  MOVF   44,W
0C35:  SUBWF  40,W
0C36:  MOVWF  4A
0C37:  MOVF   47,W
0C38:  MOVWF  4B
0C39:  MOVF   48,W
0C3A:  MOVWF  4C
0C3B:  MOVF   49,W
0C3C:  MOVWF  4D
0C3D:  MOVF   4A,W
0C3E:  MOVWF  4E
0C3F:  MOVF   43,W
0C40:  MOVWF  4F
0C41:  BCF    03.5
0C42:  CALL   0E9
....................       } 
....................       else 
0C43:  GOTO   4CC
0C44:  BSF    03.5
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
0C45:  MOVF   3F,W
0C46:  ADDWF  44,W
0C47:  MOVWF  47
0C48:  MOVF   40,W
0C49:  ADDWF  45,W
0C4A:  MOVWF  48
0C4B:  MOVF   47,W
0C4C:  MOVWF  59
0C4D:  MOVF   48,W
0C4E:  MOVWF  5A
0C4F:  MOVF   43,W
0C50:  MOVWF  5B
0C51:  BCF    0A.3
0C52:  BCF    03.5
0C53:  CALL   75F
0C54:  BSF    0A.3
....................          glcd_pixel(b+x, a+y, color); 
0C55:  BSF    03.5
0C56:  MOVF   3F,W
0C57:  ADDWF  45,W
0C58:  MOVWF  47
0C59:  MOVF   40,W
0C5A:  ADDWF  44,W
0C5B:  MOVWF  48
0C5C:  MOVF   47,W
0C5D:  MOVWF  59
0C5E:  MOVF   48,W
0C5F:  MOVWF  5A
0C60:  MOVF   43,W
0C61:  MOVWF  5B
0C62:  BCF    0A.3
0C63:  BCF    03.5
0C64:  CALL   75F
0C65:  BSF    0A.3
....................          glcd_pixel(x-a, b+y, color); 
0C66:  BSF    03.5
0C67:  MOVF   44,W
0C68:  SUBWF  3F,W
0C69:  MOVWF  47
0C6A:  MOVF   40,W
0C6B:  ADDWF  45,W
0C6C:  MOVWF  48
0C6D:  MOVF   47,W
0C6E:  MOVWF  59
0C6F:  MOVF   48,W
0C70:  MOVWF  5A
0C71:  MOVF   43,W
0C72:  MOVWF  5B
0C73:  BCF    0A.3
0C74:  BCF    03.5
0C75:  CALL   75F
0C76:  BSF    0A.3
....................          glcd_pixel(x-b, a+y, color); 
0C77:  BSF    03.5
0C78:  MOVF   45,W
0C79:  SUBWF  3F,W
0C7A:  MOVWF  47
0C7B:  MOVF   40,W
0C7C:  ADDWF  44,W
0C7D:  MOVWF  48
0C7E:  MOVF   47,W
0C7F:  MOVWF  59
0C80:  MOVF   48,W
0C81:  MOVWF  5A
0C82:  MOVF   43,W
0C83:  MOVWF  5B
0C84:  BCF    0A.3
0C85:  BCF    03.5
0C86:  CALL   75F
0C87:  BSF    0A.3
....................          glcd_pixel(b+x, y-a, color); 
0C88:  BSF    03.5
0C89:  MOVF   3F,W
0C8A:  ADDWF  45,W
0C8B:  MOVWF  47
0C8C:  MOVF   44,W
0C8D:  SUBWF  40,W
0C8E:  MOVWF  48
0C8F:  MOVF   47,W
0C90:  MOVWF  59
0C91:  MOVF   48,W
0C92:  MOVWF  5A
0C93:  MOVF   43,W
0C94:  MOVWF  5B
0C95:  BCF    0A.3
0C96:  BCF    03.5
0C97:  CALL   75F
0C98:  BSF    0A.3
....................          glcd_pixel(a+x, y-b, color); 
0C99:  BSF    03.5
0C9A:  MOVF   3F,W
0C9B:  ADDWF  44,W
0C9C:  MOVWF  47
0C9D:  MOVF   45,W
0C9E:  SUBWF  40,W
0C9F:  MOVWF  48
0CA0:  MOVF   47,W
0CA1:  MOVWF  59
0CA2:  MOVF   48,W
0CA3:  MOVWF  5A
0CA4:  MOVF   43,W
0CA5:  MOVWF  5B
0CA6:  BCF    0A.3
0CA7:  BCF    03.5
0CA8:  CALL   75F
0CA9:  BSF    0A.3
....................          glcd_pixel(x-a, y-b, color); 
0CAA:  BSF    03.5
0CAB:  MOVF   44,W
0CAC:  SUBWF  3F,W
0CAD:  MOVWF  47
0CAE:  MOVF   45,W
0CAF:  SUBWF  40,W
0CB0:  MOVWF  48
0CB1:  MOVF   47,W
0CB2:  MOVWF  59
0CB3:  MOVF   48,W
0CB4:  MOVWF  5A
0CB5:  MOVF   43,W
0CB6:  MOVWF  5B
0CB7:  BCF    0A.3
0CB8:  BCF    03.5
0CB9:  CALL   75F
0CBA:  BSF    0A.3
....................          glcd_pixel(x-b, y-a, color); 
0CBB:  BSF    03.5
0CBC:  MOVF   45,W
0CBD:  SUBWF  3F,W
0CBE:  MOVWF  47
0CBF:  MOVF   44,W
0CC0:  SUBWF  40,W
0CC1:  MOVWF  48
0CC2:  MOVF   47,W
0CC3:  MOVWF  59
0CC4:  MOVF   48,W
0CC5:  MOVWF  5A
0CC6:  MOVF   43,W
0CC7:  MOVWF  5B
0CC8:  BCF    0A.3
0CC9:  BCF    03.5
0CCA:  CALL   75F
0CCB:  BSF    0A.3
....................       } 
....................  
....................       if(P < 0) 
0CCC:  BSF    03.5
0CCD:  BTFSS  46.7
0CCE:  GOTO   4DF
....................          P+= 3 + 2*a++; 
0CCF:  MOVF   44,W
0CD0:  INCF   44,F
0CD1:  MOVWF  47
0CD2:  MOVLW  02
0CD3:  MOVWF  5A
0CD4:  MOVF   47,W
0CD5:  MOVWF  5B
0CD6:  BCF    0A.3
0CD7:  BCF    03.5
0CD8:  CALL   624
0CD9:  BSF    0A.3
0CDA:  MOVF   78,W
0CDB:  ADDLW  03
0CDC:  BSF    03.5
0CDD:  ADDWF  46,F
....................       else 
0CDE:  GOTO   4F2
....................          P+= 5 + 2*(a++ - b--); 
0CDF:  MOVF   44,W
0CE0:  INCF   44,F
0CE1:  MOVWF  47
0CE2:  MOVF   45,W
0CE3:  DECF   45,F
0CE4:  SUBWF  47,W
0CE5:  MOVWF  47
0CE6:  MOVLW  02
0CE7:  MOVWF  5A
0CE8:  MOVF   47,W
0CE9:  MOVWF  5B
0CEA:  BCF    0A.3
0CEB:  BCF    03.5
0CEC:  CALL   624
0CED:  BSF    0A.3
0CEE:  MOVF   78,W
0CEF:  ADDLW  05
0CF0:  BSF    03.5
0CF1:  ADDWF  46,F
....................     } while(a <= b); 
0CF2:  MOVF   44,W
0CF3:  XORLW  80
0CF4:  MOVWF  77
0CF5:  MOVF   45,W
0CF6:  XORLW  80
0CF7:  SUBWF  77,W
0CF8:  BTFSC  03.2
0CF9:  GOTO   3DD
0CFA:  BTFSS  03.0
0CFB:  GOTO   3DD
.................... } 
0CFC:  BCF    03.5
0CFD:  RETURN
....................  
.................... // Purpose:       Write text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ... 
.................... //                color - ON or OFF 
.................... void glcd_text57(int x, int y, char* textptr, int size, int1 color) 
.................... { 
....................    int i, j, k, l, m;                     // Loop counters 
....................    BYTE pixelData[5];                     // Stores character data 
....................  
....................    for(i=0; textptr[i] != '\0'; ++i, ++x) // Loop through the passed string 
*
0800:  BSF    03.5
0801:  CLRF   45
0802:  MOVF   45,W
0803:  ADDWF  41,W
0804:  MOVWF  04
0805:  BCF    03.7
0806:  BTFSC  42.0
0807:  BSF    03.7
0808:  MOVF   00,F
0809:  BTFSC  03.2
080A:  GOTO   0E7
....................    { 
....................       if(textptr[i] < 'S') // Checks if the letter is in the first text array 
080B:  MOVF   45,W
080C:  ADDWF  41,W
080D:  MOVWF  04
080E:  BCF    03.7
080F:  BTFSC  42.0
0810:  BSF    03.7
0811:  MOVF   00,W
0812:  SUBLW  52
0813:  BTFSS  03.0
0814:  GOTO   03D
....................          memcpy(pixelData, TEXT[textptr[i]-' '], 5); 
0815:  MOVF   45,W
0816:  ADDWF  41,W
0817:  MOVWF  04
0818:  BCF    03.7
0819:  BTFSC  42.0
081A:  BSF    03.7
081B:  MOVLW  20
081C:  SUBWF  00,W
081D:  MOVWF  50
081E:  MOVWF  5A
081F:  MOVLW  05
0820:  MOVWF  5B
0821:  BCF    0A.3
0822:  BCF    03.5
0823:  CALL   624
0824:  BSF    0A.3
0825:  MOVF   78,W
0826:  BSF    03.5
0827:  MOVWF  4F
0828:  MOVWF  79
0829:  MOVLW  05
082A:  MOVWF  78
082B:  MOVLW  CA
082C:  MOVWF  04
082D:  BCF    03.7
082E:  MOVF   79,W
082F:  BCF    0A.3
0830:  BCF    03.5
0831:  CALL   004
0832:  BSF    0A.3
0833:  MOVWF  00
0834:  INCF   79,F
0835:  INCF   04,F
0836:  DECFSZ 78,F
0837:  GOTO   039
0838:  GOTO   03B
0839:  BSF    03.5
083A:  GOTO   02E
....................       else if(textptr[i] <= '~') // Check if the letter is in the second array 
083B:  GOTO   075
083C:  BSF    03.5
083D:  MOVF   45,W
083E:  ADDWF  41,W
083F:  MOVWF  04
0840:  BCF    03.7
0841:  BTFSC  42.0
0842:  BSF    03.7
0843:  MOVF   00,W
0844:  SUBLW  7E
0845:  BTFSS  03.0
0846:  GOTO   06F
....................          memcpy(pixelData, TEXT2[textptr[i]-'S'], 5); 
0847:  MOVF   45,W
0848:  ADDWF  41,W
0849:  MOVWF  04
084A:  BCF    03.7
084B:  BTFSC  42.0
084C:  BSF    03.7
084D:  MOVLW  53
084E:  SUBWF  00,W
084F:  MOVWF  50
0850:  MOVWF  5A
0851:  MOVLW  05
0852:  MOVWF  5B
0853:  BCF    0A.3
0854:  BCF    03.5
0855:  CALL   624
0856:  BSF    0A.3
0857:  MOVF   78,W
0858:  BSF    03.5
0859:  MOVWF  4F
085A:  MOVWF  79
085B:  MOVLW  05
085C:  MOVWF  78
085D:  MOVLW  CA
085E:  MOVWF  04
085F:  BCF    03.7
0860:  MOVF   79,W
0861:  BCF    0A.3
0862:  BCF    03.5
0863:  CALL   10A
0864:  BSF    0A.3
0865:  MOVWF  00
0866:  INCF   79,F
0867:  INCF   04,F
0868:  DECFSZ 78,F
0869:  GOTO   06B
086A:  GOTO   06D
086B:  BSF    03.5
086C:  GOTO   060
....................       else 
086D:  GOTO   075
086E:  BSF    03.5
....................          memcpy(pixelData, TEXT[0], 5);   // Default to space 
086F:  CLRF   4A
0870:  CLRF   4B
0871:  CLRF   4C
0872:  CLRF   4D
0873:  CLRF   4E
0874:  BCF    03.5
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
0875:  MOVLW  05
0876:  BSF    03.5
0877:  MOVWF  5A
0878:  MOVF   43,W
0879:  MOVWF  5B
087A:  BCF    0A.3
087B:  BCF    03.5
087C:  CALL   624
087D:  BSF    0A.3
087E:  MOVF   78,W
087F:  BSF    03.5
0880:  ADDWF  3F,W
0881:  SUBLW  7F
0882:  BTFSC  03.0
0883:  GOTO   091
....................       { 
....................          x = 0;                           // Set x at far left position 
0884:  CLRF   3F
....................          y += 7*size + 1;                 // Set y at next position down 
0885:  MOVLW  07
0886:  MOVWF  5A
0887:  MOVF   43,W
0888:  MOVWF  5B
0889:  BCF    0A.3
088A:  BCF    03.5
088B:  CALL   624
088C:  BSF    0A.3
088D:  MOVLW  01
088E:  ADDWF  78,W
088F:  BSF    03.5
0890:  ADDWF  40,F
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
0891:  CLRF   46
0892:  MOVF   46,W
0893:  SUBLW  04
0894:  BTFSS  03.0
0895:  GOTO   0E4
....................       { 
....................          for(k=0; k<7*size; ++k)          // Loop through the vertical pixels 
0896:  CLRF   47
0897:  MOVLW  07
0898:  MOVWF  5A
0899:  MOVF   43,W
089A:  MOVWF  5B
089B:  BCF    0A.3
089C:  BCF    03.5
089D:  CALL   624
089E:  BSF    0A.3
089F:  MOVF   78,W
08A0:  BSF    03.5
08A1:  SUBWF  47,W
08A2:  BTFSC  03.0
08A3:  GOTO   0E0
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
08A4:  MOVLW  CA
08A5:  ADDWF  46,W
08A6:  MOVWF  04
08A7:  BCF    03.7
08A8:  MOVF   00,W
08A9:  MOVWF  4F
08AA:  MOVWF  77
08AB:  MOVF   47,W
08AC:  MOVWF  78
08AD:  BTFSC  03.2
08AE:  GOTO   0B3
08AF:  BCF    03.0
08B0:  RRF    77,F
08B1:  DECFSZ 78,F
08B2:  GOTO   0AF
08B3:  BTFSS  77.0
08B4:  GOTO   0DE
....................             { 
....................                for(l=0; l<size; ++l)      // The next two loops change the 
08B5:  CLRF   48
08B6:  MOVF   43,W
08B7:  SUBWF  48,W
08B8:  BTFSC  03.0
08B9:  GOTO   0DE
....................                {                          // character's size 
....................                   for(m=0; m<size; ++m) 
08BA:  CLRF   49
08BB:  MOVF   43,W
08BC:  SUBWF  49,W
08BD:  BTFSC  03.0
08BE:  GOTO   0DC
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
08BF:  MOVF   49,W
08C0:  ADDWF  3F,W
08C1:  MOVWF  4F
08C2:  MOVF   47,W
08C3:  MOVWF  5A
08C4:  MOVF   43,W
08C5:  MOVWF  5B
08C6:  BCF    0A.3
08C7:  BCF    03.5
08C8:  CALL   624
08C9:  BSF    0A.3
08CA:  MOVF   78,W
08CB:  BSF    03.5
08CC:  ADDWF  40,W
08CD:  ADDWF  48,W
08CE:  MOVWF  50
08CF:  MOVF   4F,W
08D0:  MOVWF  59
08D1:  MOVF   50,W
08D2:  MOVWF  5A
08D3:  MOVF   44,W
08D4:  MOVWF  5B
08D5:  BCF    0A.3
08D6:  BCF    03.5
08D7:  CALL   75F
08D8:  BSF    0A.3
....................                   } 
08D9:  BSF    03.5
08DA:  INCF   49,F
08DB:  GOTO   0BB
....................                } 
08DC:  INCF   48,F
08DD:  GOTO   0B6
....................             } 
....................          } 
08DE:  INCF   47,F
08DF:  GOTO   097
....................       } 
08E0:  INCF   46,F
08E1:  MOVF   43,W
08E2:  ADDWF  3F,F
08E3:  GOTO   092
....................    } 
08E4:  INCF   45,F
08E5:  INCF   3F,F
08E6:  GOTO   002
.................... } 
08E7:  BCF    03.5
08E8:  RETURN
....................  
....................  
.................... // Purpose:       Fill the LCD screen with the passed in color. 
.................... //                Works much faster than drawing a rectangle to fill the screen. 
.................... // Inputs:        ON - turn all the pixels on 
.................... //                OFF - turn all the pixels off 
.................... // Dependencies:  glcd_writeByte() 
.................... void glcd_fillScreen(int1 color) 
.................... { 
....................    int i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
*
064B:  BSF    03.5
064C:  CLRF   41
064D:  MOVF   41,W
064E:  SUBLW  07
064F:  BTFSS  03.0
0650:  GOTO   6A4
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
0651:  BCF    06.2
0652:  BCF    03.5
0653:  BCF    06.2
....................       glcd_writeByte(GLCD_CS1, 0b01000000);     // Set horizontal address to 0 
0654:  MOVLW  30
0655:  BSF    03.5
0656:  MOVWF  5F
0657:  MOVLW  40
0658:  MOVWF  60
0659:  BCF    03.5
065A:  CALL   5FC
....................       glcd_writeByte(GLCD_CS2, 0b01000000); 
065B:  MOVLW  31
065C:  BSF    03.5
065D:  MOVWF  5F
065E:  MOVLW  40
065F:  MOVWF  60
0660:  BCF    03.5
0661:  CALL   5FC
....................       glcd_writeByte(GLCD_CS1, i | 0b10111000); // Set page address 
0662:  BSF    03.5
0663:  MOVF   41,W
0664:  IORLW  B8
0665:  MOVWF  43
0666:  MOVLW  30
0667:  MOVWF  5F
0668:  MOVF   43,W
0669:  MOVWF  60
066A:  BCF    03.5
066B:  CALL   5FC
....................       glcd_writeByte(GLCD_CS2, i | 0b10111000); 
066C:  BSF    03.5
066D:  MOVF   41,W
066E:  IORLW  B8
066F:  MOVWF  43
0670:  MOVLW  31
0671:  MOVWF  5F
0672:  MOVF   43,W
0673:  MOVWF  60
0674:  BCF    03.5
0675:  CALL   5FC
....................       output_high(GLCD_DI);                     // Set for data 
0676:  BSF    03.5
0677:  BCF    06.2
0678:  BCF    03.5
0679:  BSF    06.2
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
067A:  BSF    03.5
067B:  CLRF   42
067C:  MOVF   42,W
067D:  SUBLW  3F
067E:  BTFSS  03.0
067F:  GOTO   6A2
....................       { 
....................          glcd_writeByte(GLCD_CS1, 0xFF*color);  // Turn pixels on or off 
0680:  MOVLW  FF
0681:  MOVWF  5A
0682:  MOVF   40,W
0683:  MOVWF  5B
0684:  BCF    03.5
0685:  CALL   624
0686:  MOVF   78,W
0687:  BSF    03.5
0688:  MOVWF  43
0689:  MOVLW  30
068A:  MOVWF  5F
068B:  MOVF   43,W
068C:  MOVWF  60
068D:  BCF    03.5
068E:  CALL   5FC
....................          glcd_writeByte(GLCD_CS2, 0xFF*color);  // Turn pixels on or off 
068F:  MOVLW  FF
0690:  BSF    03.5
0691:  MOVWF  5A
0692:  MOVF   40,W
0693:  MOVWF  5B
0694:  BCF    03.5
0695:  CALL   624
0696:  MOVF   78,W
0697:  BSF    03.5
0698:  MOVWF  43
0699:  MOVLW  31
069A:  MOVWF  5F
069B:  MOVF   43,W
069C:  MOVWF  60
069D:  BCF    03.5
069E:  CALL   5FC
....................       } 
069F:  BSF    03.5
06A0:  INCF   42,F
06A1:  GOTO   67C
....................    } 
06A2:  INCF   41,F
06A3:  GOTO   64D
.................... } 
06A4:  BCF    03.5
06A5:  RETURN
....................  
.................... // Purpose:       Write a byte of data to the specified chip 
.................... // Inputs:        chipSelect - which chip to write the data to 
.................... //                data - the byte of data to write 
....................  
.................... void glcd_writeByte(char chip, BYTE data) 
.................... { 
....................    if(chip == GLCD_CS1)       // Choose which chip to write to 
*
05FC:  BSF    03.5
05FD:  MOVF   5F,W
05FE:  SUBLW  30
05FF:  BTFSS  03.2
0600:  GOTO   606
....................       output_LOW(GLCD_CS1); 
0601:  BCF    06.0
0602:  BCF    03.5
0603:  BCF    06.0
....................    else 
0604:  GOTO   609
0605:  BSF    03.5
....................       output_LOW(GLCD_CS2); 
0606:  BCF    06.1
0607:  BCF    03.5
0608:  BCF    06.1
....................  
....................    output_low(GLCD_RW);       // Set for writing 
0609:  BSF    03.5
060A:  BCF    06.4
060B:  BCF    03.5
060C:  BCF    06.4
....................    output_d(data);            // Put the data on the port 
060D:  BSF    03.5
060E:  CLRF   08
060F:  MOVF   60,W
0610:  BCF    03.5
0611:  MOVWF  08
....................    output_high(GLCD_E);       // Pulse the enable pin 
0612:  BSF    03.5
0613:  BCF    06.5
0614:  BCF    03.5
0615:  BSF    06.5
....................    delay_us(2); 
0616:  GOTO   617
....................    output_low(GLCD_E); 
0617:  BSF    03.5
0618:  BCF    06.5
0619:  BCF    03.5
061A:  BCF    06.5
....................  
....................    output_HIGH(GLCD_CS1);      // Reset the chip select lines 
061B:  BSF    03.5
061C:  BCF    06.0
061D:  BCF    03.5
061E:  BSF    06.0
....................    output_HIGH(GLCD_CS2); 
061F:  BSF    03.5
0620:  BCF    06.1
0621:  BCF    03.5
0622:  BSF    06.1
.................... } 
0623:  RETURN
....................  
....................  
.................... // Purpose:       Reads a byte of data from the specified chip 
.................... // Ouputs:        A byte of data read from the chip 
.................... BYTE glcd_readByte(BYTE chip) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................    if(chip == GLCD_CS1)       // Choose which chip to read from 
*
078E:  MOVF   5E,W
078F:  SUBLW  30
0790:  BTFSS  03.2
0791:  GOTO   797
....................       output_LOW(GLCD_CS1); 
0792:  BCF    06.0
0793:  BCF    03.5
0794:  BCF    06.0
....................    else 
0795:  GOTO   79A
0796:  BSF    03.5
....................       output_LOW(GLCD_CS2); 
0797:  BCF    06.1
0798:  BCF    03.5
0799:  BCF    06.1
....................  
....................    input_d();                 // Set port d to input 
079A:  MOVLW  FF
079B:  BSF    03.5
079C:  MOVWF  08
....................    output_high(GLCD_RW);      // Set for reading 
079D:  BCF    06.4
079E:  BCF    03.5
079F:  BSF    06.4
....................    output_high(GLCD_E);       // Pulse the enable pin 
07A0:  BSF    03.5
07A1:  BCF    06.5
07A2:  BCF    03.5
07A3:  BSF    06.5
....................    delay_us(2); 
07A4:  GOTO   7A5
....................    output_low(GLCD_E); 
07A5:  BSF    03.5
07A6:  BCF    06.5
07A7:  BCF    03.5
07A8:  BCF    06.5
....................    delay_us(2); 
07A9:  GOTO   7AA
....................    output_high(GLCD_E);       // Pulse the enable pin 
07AA:  BSF    03.5
07AB:  BCF    06.5
07AC:  BCF    03.5
07AD:  BSF    06.5
....................    delay_us(2); 
07AE:  GOTO   7AF
....................    data = input_d();          // Get the data from the display's output register 
07AF:  MOVLW  FF
07B0:  BSF    03.5
07B1:  MOVWF  08
07B2:  BCF    03.5
07B3:  MOVF   08,W
07B4:  BSF    03.5
07B5:  MOVWF  5F
....................    output_low(GLCD_E); 
07B6:  BCF    06.5
07B7:  BCF    03.5
07B8:  BCF    06.5
....................  
....................    output_HIGH(GLCD_CS1);      // Reset the chip select lines 
07B9:  BSF    03.5
07BA:  BCF    06.0
07BB:  BCF    03.5
07BC:  BSF    06.0
....................    output_HIGH(GLCD_CS2); 
07BD:  BSF    03.5
07BE:  BCF    06.1
07BF:  BCF    03.5
07C0:  BSF    06.1
....................    return data;               // Return the read data 
07C1:  BSF    03.5
07C2:  MOVF   5F,W
07C3:  MOVWF  78
.................... } 
....................  
....................  
.................... void dibujo(char a){ 
.................... INT I=0; 
.................... OUTPUT_LOW(GLCD_RW); 
.................... OUTPUT_LOW(GLCD_DI); 
.................... glcd_writeByte(GLCD_CS1,0X40); 
.................... glcd_writeByte(GLCD_CS1,0XB8); 
.................... OUTPUT_HIGH(GLCD_DI); 
.................... glcd_writeByte(GLCD_CS1,*a); 
.................... //glcd_writeByte(GLCD_CS1,); 
.................... //glcd_writeByte(GLCD_CS1,A+2); 
.................... //glcd_writeByte(GLCD_CS1,*A+3); 
.................... } 
.................... void incrementar(int a){ 
.................... OUTPUT_LOW(GLCD_RW); 
*
0721:  BSF    03.5
0722:  BCF    06.4
0723:  BCF    03.5
0724:  BCF    06.4
.................... OUTPUT_LOW(GLCD_DI); 
0725:  BSF    03.5
0726:  BCF    06.2
0727:  BCF    03.5
0728:  BCF    06.2
.................... glcd_writeByte(GLCD_CS1,0X40 ); 
0729:  MOVLW  30
072A:  BSF    03.5
072B:  MOVWF  5F
072C:  MOVLW  40
072D:  MOVWF  60
072E:  BCF    03.5
072F:  CALL   5FC
.................... glcd_writeByte(GLCD_CS1,0XB8 + a); 
0730:  MOVLW  B8
0731:  BSF    03.5
0732:  ADDWF  3F,W
0733:  MOVWF  40
0734:  MOVLW  30
0735:  MOVWF  5F
0736:  MOVF   40,W
0737:  MOVWF  60
0738:  BCF    03.5
0739:  CALL   5FC
.................... OUTPUT_HIGH(GLCD_DI); 
073A:  BSF    03.5
073B:  BCF    06.2
073C:  BCF    03.5
073D:  BSF    06.2
.................... } 
073E:  RETURN
.................... void incrementar2(int a){ 
.................... OUTPUT_LOW(GLCD_RW); 
073F:  BSF    03.5
0740:  BCF    06.4
0741:  BCF    03.5
0742:  BCF    06.4
.................... OUTPUT_LOW(GLCD_DI); 
0743:  BSF    03.5
0744:  BCF    06.2
0745:  BCF    03.5
0746:  BCF    06.2
.................... glcd_writeByte(GLCD_CS2,0X40 ); 
0747:  MOVLW  31
0748:  BSF    03.5
0749:  MOVWF  5F
074A:  MOVLW  40
074B:  MOVWF  60
074C:  BCF    03.5
074D:  CALL   5FC
.................... glcd_writeByte(GLCD_CS2,0XB8 + a); 
074E:  MOVLW  B8
074F:  BSF    03.5
0750:  ADDWF  3F,W
0751:  MOVWF  40
0752:  MOVLW  31
0753:  MOVWF  5F
0754:  MOVF   40,W
0755:  MOVWF  60
0756:  BCF    03.5
0757:  CALL   5FC
.................... OUTPUT_HIGH(GLCD_DI); 
0758:  BSF    03.5
0759:  BCF    06.2
075A:  BCF    03.5
075B:  BSF    06.2
.................... } 
075C:  BCF    0A.3
075D:  BSF    0A.4
075E:  GOTO   47F (RETURN)
....................  
.................... #endif 
....................  
.................... #fuses XT,NOWDT,PUT 
.................... #byte porta=0x05 
.................... #byte portd=0x08 
.................... #byte trisa=0x85 
.................... #byte trisd=0x88 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Pantalla de inicio                                                   / 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... const unsigned char nico [512] = { 
.................... 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0xF0, 0x90, 0x10, 0x60, 0x80, 0x00, 0x00, 0xF0, 0x10, 0xF0, 0x00, 0x00, 0xB8, 0xA8, 0xB8, 
.................... 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 
.................... 0x80, 0x80, 0x00, 0x00, 0x00, 0xC0, 0x20, 0xD0, 0x50, 0x50, 0x50, 0xD0, 0xA0, 0xC0, 0x00, 0x80, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 
.................... 0x08, 0xFF, 0x80, 0xFF, 0x06, 0x09, 0x36, 0x48, 0x9F, 0x80, 0xFF, 0x00, 0x00, 0xFF, 0x80, 0xFF, 
.................... 0x00, 0x00, 0x3E, 0x41, 0x9C, 0xA2, 0xA2, 0xB6, 0x55, 0x36, 0x00, 0x3E, 0x41, 0x9C, 0xA2, 0xA2, 
.................... 0xA2, 0x9C, 0x41, 0x3E, 0x00, 0x31, 0x52, 0xB5, 0xA6, 0xAA, 0xAA, 0xAA, 0xD4, 0x44, 0x38, 0x03, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 
.................... 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
.................... 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
.................... 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0C, 0x1E, 0x1E, 0x1C, 0x20, 0x20, 0x40, 0x40, 0x80, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 
.................... 0x01, 0x01, 0xFF, 0x00, 0xFE, 0x01, 0x01, 0xFF, 0x00, 0x00, 0x01, 0x01, 0xFF, 0x00, 0x00, 0xFF, 
.................... 0x01, 0x01, 0xFE, 0x00, 0xFF, 0x01, 0x01, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x01, 0x01, 0x00, 0x00, 0xFF, 0x01, 0x01, 0xFF, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 
.................... 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 
.................... 0x00, 0x00, 0x7F, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 
.................... 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 
.................... 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
.................... 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01 
.................... }; 
.................... const unsigned char mitad [512] = { 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 
.................... 0x00, 0x80, 0xE0, 0x20, 0xE0, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 
.................... 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x1C, 0x61, 0x8E, 0x30, 0xCE, 0x39, 0x07, 0x00, 0x00, 0x67, 0xA9, 0xB6, 0xAA, 0xBA, 0xAA, 0xCB, 
.................... 0x70, 0x03, 0x7E, 0x80, 0xBE, 0xE3, 0x00, 0x3E, 0x61, 0xD4, 0xB6, 0xB6, 0xB6, 0xD4, 0x51, 0x5E, 
.................... 0x00, 0xFF, 0x82, 0xFD, 0x02, 0x02, 0xFE, 0x81, 0xFD, 0x02, 0x02, 0xFE, 0x81, 0xFF, 0x08, 0x08, 
.................... 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x8E, 0x0A, 0x0B, 0x06, 0x01, 0x00, 0x00, 0x0C, 0x1E, 0x1E, 0x0C, 0x08, 0x08, 0x08, 0x08, 0x08, 
.................... 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
.................... 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
.................... 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x01, 0x03, 0x02, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0xFF, 0x01, 0x01, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x01, 0x01, 0x00, 0x00, 
.................... 0xFF, 0x01, 0x01, 0x00, 0x00, 0xFF, 0x01, 0x01, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 
.................... 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x01, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
.................... 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 
.................... 0x01, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
.................... 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 
.................... }; 
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //Declaracion de funciones y variables                                 / 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... char titulo[]="Control Remoto"; 
*
12C1:  MOVLW  43
12C2:  MOVWF  23
12C3:  MOVLW  6F
12C4:  MOVWF  24
12C5:  MOVLW  6E
12C6:  MOVWF  25
12C7:  MOVLW  74
12C8:  MOVWF  26
12C9:  MOVLW  72
12CA:  MOVWF  27
12CB:  MOVLW  6F
12CC:  MOVWF  28
12CD:  MOVLW  6C
12CE:  MOVWF  29
12CF:  MOVLW  20
12D0:  MOVWF  2A
12D1:  MOVLW  52
12D2:  MOVWF  2B
12D3:  MOVLW  65
12D4:  MOVWF  2C
12D5:  MOVLW  6D
12D6:  MOVWF  2D
12D7:  MOVLW  6F
12D8:  MOVWF  2E
12D9:  MOVLW  74
12DA:  MOVWF  2F
12DB:  MOVLW  6F
12DC:  MOVWF  30
12DD:  CLRF   31
.................... char luces[]="Luces"; 
12DE:  MOVLW  4C
12DF:  MOVWF  32
12E0:  MOVLW  75
12E1:  MOVWF  33
12E2:  MOVLW  63
12E3:  MOVWF  34
12E4:  MOVLW  65
12E5:  MOVWF  35
12E6:  MOVLW  73
12E7:  MOVWF  36
12E8:  CLRF   37
.................... char audio[]="Audio"; 
12E9:  MOVLW  41
12EA:  MOVWF  38
12EB:  MOVLW  75
12EC:  MOVWF  39
12ED:  MOVLW  64
12EE:  MOVWF  3A
12EF:  MOVLW  69
12F0:  MOVWF  3B
12F1:  MOVLW  6F
12F2:  MOVWF  3C
12F3:  CLRF   3D
.................... char cortina[]="Cortinas"; 
12F4:  MOVLW  43
12F5:  MOVWF  3E
12F6:  MOVLW  6F
12F7:  MOVWF  3F
12F8:  MOVLW  72
12F9:  MOVWF  40
12FA:  MOVLW  74
12FB:  MOVWF  41
12FC:  MOVLW  69
12FD:  MOVWF  42
12FE:  MOVLW  6E
12FF:  MOVWF  43
1300:  MOVLW  61
1301:  MOVWF  44
1302:  MOVLW  73
1303:  MOVWF  45
1304:  CLRF   46
.................... char ampli[]="Amplificador"; 
1305:  MOVLW  41
1306:  MOVWF  47
1307:  MOVLW  6D
1308:  MOVWF  48
1309:  MOVLW  70
130A:  MOVWF  49
130B:  MOVLW  6C
130C:  MOVWF  4A
130D:  MOVLW  69
130E:  MOVWF  4B
130F:  MOVLW  66
1310:  MOVWF  4C
1311:  MOVLW  69
1312:  MOVWF  4D
1313:  MOVLW  63
1314:  MOVWF  4E
1315:  MOVLW  61
1316:  MOVWF  4F
1317:  MOVLW  64
1318:  MOVWF  50
1319:  MOVLW  6F
131A:  MOVWF  51
131B:  MOVLW  72
131C:  MOVWF  52
131D:  CLRF   53
.................... char prende[]="prender"; 
131E:  MOVLW  70
131F:  MOVWF  54
1320:  MOVLW  72
1321:  MOVWF  55
1322:  MOVLW  65
1323:  MOVWF  56
1324:  MOVLW  6E
1325:  MOVWF  57
1326:  MOVLW  64
1327:  MOVWF  58
1328:  MOVLW  65
1329:  MOVWF  59
132A:  MOVLW  72
132B:  MOVWF  5A
132C:  CLRF   5B
.................... char apaga[]="apagar"; 
132D:  MOVLW  61
132E:  MOVWF  5C
132F:  MOVLW  70
1330:  MOVWF  5D
1331:  MOVLW  61
1332:  MOVWF  5E
1333:  MOVLW  67
1334:  MOVWF  5F
1335:  MOVLW  61
1336:  MOVWF  60
1337:  MOVLW  72
1338:  MOVWF  61
1339:  CLRF   62
.................... char menu1[]="Menu"; 
133A:  MOVLW  4D
133B:  MOVWF  63
133C:  MOVLW  65
133D:  MOVWF  64
133E:  MOVLW  6E
133F:  MOVWF  65
1340:  MOVLW  75
1341:  MOVWF  66
1342:  CLRF   67
.................... char volumen[]="Volumen"; 
1343:  MOVLW  56
1344:  MOVWF  68
1345:  MOVLW  6F
1346:  MOVWF  69
1347:  MOVLW  6C
1348:  MOVWF  6A
1349:  MOVLW  75
134A:  MOVWF  6B
134B:  MOVLW  6D
134C:  MOVWF  6C
134D:  MOVLW  65
134E:  MOVWF  6D
134F:  MOVLW  6E
1350:  MOVWF  6E
1351:  CLRF   6F
.................... char PUNTA[]="Punta"; 
1352:  MOVLW  50
1353:  MOVWF  70
1354:  MOVLW  75
1355:  MOVWF  71
1356:  MOVLW  6E
1357:  MOVWF  72
1358:  MOVLW  74
1359:  MOVWF  73
135A:  MOVLW  61
135B:  MOVWF  74
135C:  CLRF   75
.................... char centro[]="Centro"; 
135D:  MOVLW  43
135E:  BSF    03.5
135F:  MOVWF  20
1360:  MOVLW  65
1361:  MOVWF  21
1362:  MOVLW  6E
1363:  MOVWF  22
1364:  MOVLW  74
1365:  MOVWF  23
1366:  MOVLW  72
1367:  MOVWF  24
1368:  MOVLW  6F
1369:  MOVWF  25
136A:  CLRF   26
.................... char todos[]="Todos"; 
136B:  MOVLW  54
136C:  MOVWF  27
136D:  MOVLW  6F
136E:  MOVWF  28
136F:  MOVLW  64
1370:  MOVWF  29
1371:  MOVLW  6F
1372:  MOVWF  2A
1373:  MOVLW  73
1374:  MOVWF  2B
1375:  CLRF   2C
.................... char non[]= "NO"; 
1376:  MOVLW  4E
1377:  MOVWF  7C
1378:  MOVLW  4F
1379:  MOVWF  7D
137A:  CLRF   7E
.................... char sis[]= "SI"; 
137B:  MOVLW  53
137C:  MOVWF  2D
137D:  MOVLW  49
137E:  MOVWF  2E
137F:  CLRF   2F
.................... void pulsaluz(); 
.................... void pulsaaudio(); 
.................... void pulsacortina(); 
.................... void menu(); 
.................... void solto(); 
.................... void posicion(); 
.................... int menuluz(); 
.................... int menuaudio(); 
.................... int menucortinas(); 
....................  
.................... char c=""; 
.................... int16 getx(); 
.................... int16 gety(); 
.................... char x; 
.................... char y; 
.................... int16 x_coord; 
.................... int16 y_coord; 
.................... int16 x_coord128; 
.................... int16 y_coord64; 
.................... int8 selector=0; 
.................... int16 i=0; 
.................... int a=0; 
.................... char mensaje; 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Programa principal                                                   / 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... void main(){ 
*
12A4:  CLRF   04
12A5:  BCF    03.7
12A6:  MOVLW  1F
12A7:  ANDWF  03,F
12A8:  MOVLW  19
12A9:  BSF    03.5
12AA:  MOVWF  19
12AB:  MOVLW  A2
12AC:  MOVWF  18
12AD:  MOVLW  90
12AE:  BCF    03.5
12AF:  MOVWF  18
12B0:  MOVLW  FF
12B1:  MOVWF  22
12B2:  CLRF   76
12B3:  BSF    03.5
12B4:  CLRF   3A
12B5:  CLRF   3C
12B6:  CLRF   3B
12B7:  CLRF   3D
12B8:  BSF    1F.0
12B9:  BSF    1F.1
12BA:  BSF    1F.2
12BB:  BCF    1F.3
12BC:  MOVLW  07
12BD:  MOVWF  1C
.................... porta=0; 
*
1380:  BCF    03.5
1381:  CLRF   05
.................... SET_TRIS_A(0x0b); 
1382:  MOVLW  0B
1383:  BSF    03.5
1384:  MOVWF  05
.................... SET_TRIS_B(0x00); 
1385:  MOVLW  00
1386:  MOVWF  06
.................... SET_TRIS_C(0x80); 
1387:  MOVLW  80
1388:  MOVWF  07
1389:  BCF    03.5
138A:  MOVWF  22
.................... SET_TRIS_D(0x00); 
138B:  MOVLW  00
138C:  BSF    03.5
138D:  MOVWF  08
.................... SET_TRIS_E(0x00); 
138E:  BCF    09.0
138F:  BCF    09.1
1390:  BCF    09.2
....................  
.................... output_high(PIN_B7); 
1391:  BCF    06.7
1392:  BCF    03.5
1393:  BSF    06.7
.................... setup_adc_ports(AN0_AN1_AN3);// PUERTO A1 COMO ANAL 
1394:  BSF    03.5
1395:  BCF    1F.0
1396:  BCF    1F.1
1397:  BSF    1F.2
1398:  BCF    1F.3
.................... setup_adc(ADC_CLOCK_INTERNAL); // configuro ADC 
1399:  BCF    1F.6
139A:  BCF    03.5
139B:  BSF    1F.6
139C:  BSF    1F.7
139D:  BSF    03.5
139E:  BSF    1F.7
139F:  BCF    03.5
13A0:  BSF    1F.0
.................... glcd_init(on); 
13A1:  MOVLW  01
13A2:  BSF    03.5
13A3:  MOVWF  3F
13A4:  BCF    0A.4
13A5:  BCF    03.5
13A6:  GOTO   6A6
13A7:  BSF    0A.4
.................... glcd_fillScreen(OFF); 
13A8:  BSF    03.5
13A9:  CLRF   40
13AA:  BCF    0A.4
13AB:  BCF    03.5
13AC:  CALL   64B
13AD:  BSF    0A.4
.................... DELAY_MS(1000); 
13AE:  MOVLW  04
13AF:  BSF    03.5
13B0:  MOVWF  3F
13B1:  MOVLW  FA
13B2:  MOVWF  40
13B3:  BCF    0A.4
13B4:  BCF    03.5
13B5:  CALL   70C
13B6:  BSF    0A.4
13B7:  BSF    03.5
13B8:  DECFSZ 3F,F
13B9:  GOTO   3B1
.................... a=0; 
13BA:  CLRF   3D
.................... incrementar(a); 
13BB:  MOVF   3D,W
13BC:  MOVWF  3F
13BD:  BCF    0A.4
13BE:  BCF    03.5
13BF:  CALL   721
13C0:  BSF    0A.4
.................... i=0; 
13C1:  BSF    03.5
13C2:  CLRF   3C
13C3:  CLRF   3B
.................... while(i<512){ 
13C4:  MOVF   3C,W
13C5:  SUBLW  01
13C6:  BTFSS  03.0
13C7:  GOTO   41E
.................... glcd_writeByte(GLCD_CS1,nico[i]); 
13C8:  MOVF   3C,W
13C9:  MOVWF  7A
13CA:  MOVF   3B,W
13CB:  BCF    0A.4
13CC:  BCF    03.5
13CD:  CALL   1EA
13CE:  BSF    0A.4
13CF:  BSF    03.5
13D0:  MOVWF  3F
13D1:  MOVLW  30
13D2:  MOVWF  5F
13D3:  MOVF   3F,W
13D4:  MOVWF  60
13D5:  BCF    0A.4
13D6:  BCF    03.5
13D7:  CALL   5FC
13D8:  BSF    0A.4
.................... i++; 
13D9:  BSF    03.5
13DA:  INCF   3B,F
13DB:  BTFSC  03.2
13DC:  INCF   3C,F
.................... if (i==64 || i==128 || i==192 || i==256 || i==320 || i==384 || i==448 || i==512){ 
13DD:  MOVF   3B,W
13DE:  SUBLW  40
13DF:  BTFSS  03.2
13E0:  GOTO   3E4
13E1:  MOVF   3C,F
13E2:  BTFSC  03.2
13E3:  GOTO   414
13E4:  MOVF   3B,W
13E5:  SUBLW  80
13E6:  BTFSS  03.2
13E7:  GOTO   3EB
13E8:  MOVF   3C,F
13E9:  BTFSC  03.2
13EA:  GOTO   414
13EB:  MOVF   3B,W
13EC:  SUBLW  C0
13ED:  BTFSS  03.2
13EE:  GOTO   3F2
13EF:  MOVF   3C,F
13F0:  BTFSC  03.2
13F1:  GOTO   414
13F2:  MOVF   3B,F
13F3:  BTFSS  03.2
13F4:  GOTO   3F8
13F5:  DECFSZ 3C,W
13F6:  GOTO   3F8
13F7:  GOTO   414
13F8:  MOVF   3B,W
13F9:  SUBLW  40
13FA:  BTFSS  03.2
13FB:  GOTO   3FF
13FC:  DECFSZ 3C,W
13FD:  GOTO   3FF
13FE:  GOTO   414
13FF:  MOVF   3B,W
1400:  SUBLW  80
1401:  BTFSS  03.2
1402:  GOTO   406
1403:  DECFSZ 3C,W
1404:  GOTO   406
1405:  GOTO   414
1406:  MOVF   3B,W
1407:  SUBLW  C0
1408:  BTFSS  03.2
1409:  GOTO   40D
140A:  DECFSZ 3C,W
140B:  GOTO   40D
140C:  GOTO   414
140D:  MOVF   3B,F
140E:  BTFSS  03.2
140F:  GOTO   41D
1410:  MOVF   3C,W
1411:  SUBLW  02
1412:  BTFSS  03.2
1413:  GOTO   41D
.................... a=a+1; 
1414:  MOVLW  01
1415:  ADDWF  3D,F
.................... incrementar (a); 
1416:  MOVF   3D,W
1417:  MOVWF  3F
1418:  BCF    0A.4
1419:  BCF    03.5
141A:  CALL   721
141B:  BSF    0A.4
141C:  BSF    03.5
.................... } 
.................... } 
141D:  GOTO   3C4
.................... a=0; 
141E:  CLRF   3D
.................... incrementar(a); 
141F:  MOVF   3D,W
1420:  MOVWF  3F
1421:  BCF    0A.4
1422:  BCF    03.5
1423:  CALL   721
1424:  BSF    0A.4
.................... i=0; 
1425:  BSF    03.5
1426:  CLRF   3C
1427:  CLRF   3B
.................... while(i<512){ 
1428:  MOVF   3C,W
1429:  SUBLW  01
142A:  BTFSS  03.0
142B:  GOTO   482
.................... glcd_writeByte(GLCD_CS2,mitad[i]); 
142C:  MOVF   3C,W
142D:  MOVWF  7A
142E:  MOVF   3B,W
142F:  BCF    0A.4
1430:  BCF    03.5
1431:  CALL   3F3
1432:  BSF    0A.4
1433:  BSF    03.5
1434:  MOVWF  3F
1435:  MOVLW  31
1436:  MOVWF  5F
1437:  MOVF   3F,W
1438:  MOVWF  60
1439:  BCF    0A.4
143A:  BCF    03.5
143B:  CALL   5FC
143C:  BSF    0A.4
.................... i++; 
143D:  BSF    03.5
143E:  INCF   3B,F
143F:  BTFSC  03.2
1440:  INCF   3C,F
.................... if (i==64 || i==128 || i==192 || i==256 || i==320 || i==384 || i==448 || i==512){ 
1441:  MOVF   3B,W
1442:  SUBLW  40
1443:  BTFSS  03.2
1444:  GOTO   448
1445:  MOVF   3C,F
1446:  BTFSC  03.2
1447:  GOTO   478
1448:  MOVF   3B,W
1449:  SUBLW  80
144A:  BTFSS  03.2
144B:  GOTO   44F
144C:  MOVF   3C,F
144D:  BTFSC  03.2
144E:  GOTO   478
144F:  MOVF   3B,W
1450:  SUBLW  C0
1451:  BTFSS  03.2
1452:  GOTO   456
1453:  MOVF   3C,F
1454:  BTFSC  03.2
1455:  GOTO   478
1456:  MOVF   3B,F
1457:  BTFSS  03.2
1458:  GOTO   45C
1459:  DECFSZ 3C,W
145A:  GOTO   45C
145B:  GOTO   478
145C:  MOVF   3B,W
145D:  SUBLW  40
145E:  BTFSS  03.2
145F:  GOTO   463
1460:  DECFSZ 3C,W
1461:  GOTO   463
1462:  GOTO   478
1463:  MOVF   3B,W
1464:  SUBLW  80
1465:  BTFSS  03.2
1466:  GOTO   46A
1467:  DECFSZ 3C,W
1468:  GOTO   46A
1469:  GOTO   478
146A:  MOVF   3B,W
146B:  SUBLW  C0
146C:  BTFSS  03.2
146D:  GOTO   471
146E:  DECFSZ 3C,W
146F:  GOTO   471
1470:  GOTO   478
1471:  MOVF   3B,F
1472:  BTFSS  03.2
1473:  GOTO   481
1474:  MOVF   3C,W
1475:  SUBLW  02
1476:  BTFSS  03.2
1477:  GOTO   481
.................... a=a+1; 
1478:  MOVLW  01
1479:  ADDWF  3D,F
.................... incrementar2 (a); 
147A:  MOVF   3D,W
147B:  MOVWF  3F
147C:  BCF    0A.4
147D:  BCF    03.5
147E:  GOTO   73F
147F:  BSF    0A.4
1480:  BSF    03.5
.................... } 
.................... } 
1481:  GOTO   428
.................... delay_ms (2000); 
1482:  MOVLW  08
1483:  MOVWF  3F
1484:  MOVLW  FA
1485:  MOVWF  40
1486:  BCF    0A.4
1487:  BCF    03.5
1488:  CALL   70C
1489:  BSF    0A.4
148A:  BSF    03.5
148B:  DECFSZ 3F,F
148C:  GOTO   484
.................... glcd_fillScreen(OFF); 
148D:  CLRF   40
148E:  BCF    0A.4
148F:  BCF    03.5
1490:  CALL   64B
1491:  BSF    0A.4
.................... selector=0; 
1492:  BSF    03.5
1493:  CLRF   3A
.................... menu(); 
1494:  BCF    0A.4
1495:  BSF    0A.3
1496:  BCF    03.5
1497:  CALL   23C
1498:  BSF    0A.4
1499:  BCF    0A.3
.................... while(true){ 
....................  
.................... x=getx(); 
149A:  BCF    0A.4
149B:  BSF    0A.3
149C:  CALL   2E3
149D:  BSF    0A.4
149E:  BCF    0A.3
149F:  MOVF   78,W
14A0:  BSF    03.5
14A1:  MOVWF  30
.................... y=gety(); 
14A2:  BCF    0A.4
14A3:  BSF    0A.3
14A4:  BCF    03.5
14A5:  CALL   34B
14A6:  BSF    0A.4
14A7:  BCF    0A.3
14A8:  MOVF   78,W
14A9:  BSF    03.5
14AA:  MOVWF  31
.................... if ( x>=11 && x<=60 && y>=20 && y<=30){ 
14AB:  MOVF   30,W
14AC:  SUBLW  0A
14AD:  BTFSC  03.0
14AE:  GOTO   4D4
14AF:  MOVF   30,W
14B0:  SUBLW  3C
14B1:  BTFSS  03.0
14B2:  GOTO   4D4
14B3:  MOVF   31,W
14B4:  SUBLW  13
14B5:  BTFSC  03.0
14B6:  GOTO   4D4
14B7:  MOVF   31,W
14B8:  SUBLW  1E
14B9:  BTFSS  03.0
14BA:  GOTO   4D4
....................    pulsaluz(); 
14BB:  BCF    0A.4
14BC:  BSF    0A.3
14BD:  BCF    03.5
14BE:  GOTO   392
14BF:  BSF    0A.4
14C0:  BCF    0A.3
....................    menuluz(); 
14C1:  BCF    0A.4
14C2:  BSF    0A.3
14C3:  GOTO   4FE
14C4:  BSF    0A.4
14C5:  BCF    0A.3
....................    delay_ms(1000); 
14C6:  MOVLW  04
14C7:  BSF    03.5
14C8:  MOVWF  3F
14C9:  MOVLW  FA
14CA:  MOVWF  40
14CB:  BCF    0A.4
14CC:  BCF    03.5
14CD:  CALL   70C
14CE:  BSF    0A.4
14CF:  BSF    03.5
14D0:  DECFSZ 3F,F
14D1:  GOTO   4C9
....................    x=0; 
14D2:  CLRF   30
....................    y=0; 
14D3:  CLRF   31
.................... } 
....................  
.................... if ( x>=66 && x<=115 && y>=20 && y<=30){ 
14D4:  MOVF   30,W
14D5:  SUBLW  41
14D6:  BTFSC  03.0
14D7:  GOTO   4F9
14D8:  MOVF   30,W
14D9:  SUBLW  73
14DA:  BTFSS  03.0
14DB:  GOTO   4F9
14DC:  MOVF   31,W
14DD:  SUBLW  13
14DE:  BTFSC  03.0
14DF:  GOTO   4F9
14E0:  MOVF   31,W
14E1:  SUBLW  1E
14E2:  BTFSS  03.0
14E3:  GOTO   4F9
....................    pulsaaudio(); 
14E4:  BCF    0A.4
14E5:  BSF    0A.3
14E6:  BCF    03.5
14E7:  GOTO   731
14E8:  BSF    0A.4
14E9:  BCF    0A.3
....................    menuaudio(); 
14EA:  GOTO   000
....................    delay_ms(1000); 
14EB:  MOVLW  04
14EC:  BSF    03.5
14ED:  MOVWF  3F
14EE:  MOVLW  FA
14EF:  MOVWF  40
14F0:  BCF    0A.4
14F1:  BCF    03.5
14F2:  CALL   70C
14F3:  BSF    0A.4
14F4:  BSF    03.5
14F5:  DECFSZ 3F,F
14F6:  GOTO   4EE
....................    x=0; 
14F7:  CLRF   30
....................    y=0;} 
14F8:  CLRF   31
.................... //presiona audio 
.................... if ( x>=11 && x<=40 && y>=45 && y<=56){ 
14F9:  MOVF   30,W
14FA:  SUBLW  0A
14FB:  BTFSC  03.0
14FC:  GOTO   51E
14FD:  MOVF   30,W
14FE:  SUBLW  28
14FF:  BTFSS  03.0
1500:  GOTO   51E
1501:  MOVF   31,W
1502:  SUBLW  2C
1503:  BTFSC  03.0
1504:  GOTO   51E
1505:  MOVF   31,W
1506:  SUBLW  38
1507:  BTFSS  03.0
1508:  GOTO   51E
....................    pulsacortina(); 
1509:  BCF    0A.4
150A:  BSF    0A.3
150B:  BCF    03.5
150C:  GOTO   775
150D:  BSF    0A.4
150E:  BCF    0A.3
....................    menucortinas(); 
150F:  GOTO   23B
....................    delay_ms(1000); 
1510:  MOVLW  04
1511:  BSF    03.5
1512:  MOVWF  3F
1513:  MOVLW  FA
1514:  MOVWF  40
1515:  BCF    0A.4
1516:  BCF    03.5
1517:  CALL   70C
1518:  BSF    0A.4
1519:  BSF    03.5
151A:  DECFSZ 3F,F
151B:  GOTO   513
....................    x=0; 
151C:  CLRF   30
....................    y=0;} 
151D:  CLRF   31
.................... }//presiona cortinas 
151E:  BCF    03.5
151F:  GOTO   49A
....................  
.................... } 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //Funcion para declarar lla pulsada de luz                              / 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... void pulsaluz(){ 
....................    glcd_rect(11, 23,60 ,35 , YES , ON ); 
*
0B92:  MOVLW  0B
0B93:  BSF    03.5
0B94:  MOVWF  3F
0B95:  MOVLW  17
0B96:  MOVWF  40
0B97:  MOVLW  3C
0B98:  MOVWF  41
0B99:  MOVLW  23
0B9A:  MOVWF  42
0B9B:  MOVLW  01
0B9C:  MOVWF  43
0B9D:  MOVWF  44
0B9E:  BCF    03.5
0B9F:  CALL   1E1
*
1520:  SLEEP
....................    glcd_text57(22,25,luces,1,off) ; 
*
0BA0:  MOVLW  16
0BA1:  BSF    03.5
0BA2:  MOVWF  3F
0BA3:  MOVLW  19
0BA4:  MOVWF  40
0BA5:  CLRF   42
0BA6:  MOVLW  32
0BA7:  MOVWF  41
0BA8:  MOVLW  01
0BA9:  MOVWF  43
0BAA:  CLRF   44
0BAB:  BCF    03.5
0BAC:  CALL   000
.................... // HACER QUE SUELTE LO PULSADO 
....................    delay_ms (1000); 
0BAD:  MOVLW  04
0BAE:  BSF    03.5
0BAF:  MOVWF  3F
0BB0:  MOVLW  FA
0BB1:  MOVWF  40
0BB2:  BCF    0A.3
0BB3:  BCF    03.5
0BB4:  CALL   70C
0BB5:  BSF    0A.3
0BB6:  BSF    03.5
0BB7:  DECFSZ 3F,F
0BB8:  GOTO   3B0
....................    glcd_rect(12, 24,59 ,34 , yes , off ); 
0BB9:  MOVLW  0C
0BBA:  MOVWF  3F
0BBB:  MOVLW  18
0BBC:  MOVWF  40
0BBD:  MOVLW  3B
0BBE:  MOVWF  41
0BBF:  MOVLW  22
0BC0:  MOVWF  42
0BC1:  MOVLW  01
0BC2:  MOVWF  43
0BC3:  CLRF   44
0BC4:  BCF    03.5
0BC5:  CALL   1E1
....................    glcd_text57(22,25,luces,1,on) ; 
0BC6:  MOVLW  16
0BC7:  BSF    03.5
0BC8:  MOVWF  3F
0BC9:  MOVLW  19
0BCA:  MOVWF  40
0BCB:  CLRF   42
0BCC:  MOVLW  32
0BCD:  MOVWF  41
0BCE:  MOVLW  01
0BCF:  MOVWF  43
0BD0:  MOVWF  44
0BD1:  BCF    03.5
0BD2:  CALL   000
.................... } 
0BD3:  BCF    0A.3
0BD4:  BSF    0A.4
0BD5:  GOTO   4BF (RETURN)
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //Funcion de pulsacion de audio                                         / 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... void pulsaaudio(){ 
....................    glcd_rect(66, 22,115 ,35 , yes , ON );//3 Auido 
*
0F31:  MOVLW  42
0F32:  BSF    03.5
0F33:  MOVWF  3F
0F34:  MOVLW  16
0F35:  MOVWF  40
0F36:  MOVLW  73
0F37:  MOVWF  41
0F38:  MOVLW  23
0F39:  MOVWF  42
0F3A:  MOVLW  01
0F3B:  MOVWF  43
0F3C:  MOVWF  44
0F3D:  BCF    03.5
0F3E:  CALL   1E1
....................    glcd_text57(76,25,audio,1,off) ; 
0F3F:  MOVLW  4C
0F40:  BSF    03.5
0F41:  MOVWF  3F
0F42:  MOVLW  19
0F43:  MOVWF  40
0F44:  CLRF   42
0F45:  MOVLW  38
0F46:  MOVWF  41
0F47:  MOVLW  01
0F48:  MOVWF  43
0F49:  CLRF   44
0F4A:  BCF    03.5
0F4B:  CALL   000
.................... // HACER QUE SUELTE LO PULSADO 
....................    delay_ms (1000); 
0F4C:  MOVLW  04
0F4D:  BSF    03.5
0F4E:  MOVWF  3F
0F4F:  MOVLW  FA
0F50:  MOVWF  40
0F51:  BCF    0A.3
0F52:  BCF    03.5
0F53:  CALL   70C
0F54:  BSF    0A.3
0F55:  BSF    03.5
0F56:  DECFSZ 3F,F
0F57:  GOTO   74F
....................    glcd_rect(67, 23,114 ,34 , yes , off );//3 Auido 
0F58:  MOVLW  43
0F59:  MOVWF  3F
0F5A:  MOVLW  17
0F5B:  MOVWF  40
0F5C:  MOVLW  72
0F5D:  MOVWF  41
0F5E:  MOVLW  22
0F5F:  MOVWF  42
0F60:  MOVLW  01
0F61:  MOVWF  43
0F62:  CLRF   44
0F63:  BCF    03.5
0F64:  CALL   1E1
....................    glcd_text57(76,25,audio,1,yes) ; 
0F65:  MOVLW  4C
0F66:  BSF    03.5
0F67:  MOVWF  3F
0F68:  MOVLW  19
0F69:  MOVWF  40
0F6A:  CLRF   42
0F6B:  MOVLW  38
0F6C:  MOVWF  41
0F6D:  MOVLW  01
0F6E:  MOVWF  43
0F6F:  MOVWF  44
0F70:  BCF    03.5
0F71:  CALL   000
.................... } 
0F72:  BCF    0A.3
0F73:  BSF    0A.4
0F74:  GOTO   4E8 (RETURN)
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //funcion para pulsar cortina                                           / 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... void pulsacortina(){ 
....................    glcd_rect(11, 41,60 ,56 , YES, ON ); 
0F75:  MOVLW  0B
0F76:  BSF    03.5
0F77:  MOVWF  3F
0F78:  MOVLW  29
0F79:  MOVWF  40
0F7A:  MOVLW  3C
0F7B:  MOVWF  41
0F7C:  MOVLW  38
0F7D:  MOVWF  42
0F7E:  MOVLW  01
0F7F:  MOVWF  43
0F80:  MOVWF  44
0F81:  BCF    03.5
0F82:  CALL   1E1
....................    glcd_text57(13,44,cortina,1,off) ; 
0F83:  MOVLW  0D
0F84:  BSF    03.5
0F85:  MOVWF  3F
0F86:  MOVLW  2C
0F87:  MOVWF  40
0F88:  CLRF   42
0F89:  MOVLW  3E
0F8A:  MOVWF  41
0F8B:  MOVLW  01
0F8C:  MOVWF  43
0F8D:  CLRF   44
0F8E:  BCF    03.5
0F8F:  CALL   000
.................... // HACER QUE SUELTE LO PULSADO 
....................    delay_ms (1000); 
0F90:  MOVLW  04
0F91:  BSF    03.5
0F92:  MOVWF  3F
0F93:  MOVLW  FA
0F94:  MOVWF  40
0F95:  BCF    0A.3
0F96:  BCF    03.5
0F97:  CALL   70C
0F98:  BSF    0A.3
0F99:  BSF    03.5
0F9A:  DECFSZ 3F,F
0F9B:  GOTO   793
....................    glcd_rect(12, 42,59 ,55 , yes, off); 
0F9C:  MOVLW  0C
0F9D:  MOVWF  3F
0F9E:  MOVLW  2A
0F9F:  MOVWF  40
0FA0:  MOVLW  3B
0FA1:  MOVWF  41
0FA2:  MOVLW  37
0FA3:  MOVWF  42
0FA4:  MOVLW  01
0FA5:  MOVWF  43
0FA6:  CLRF   44
0FA7:  BCF    03.5
0FA8:  CALL   1E1
....................    glcd_text57(13,44,cortina,1,on) ; 
0FA9:  MOVLW  0D
0FAA:  BSF    03.5
0FAB:  MOVWF  3F
0FAC:  MOVLW  2C
0FAD:  MOVWF  40
0FAE:  CLRF   42
0FAF:  MOVLW  3E
0FB0:  MOVWF  41
0FB1:  MOVLW  01
0FB2:  MOVWF  43
0FB3:  MOVWF  44
0FB4:  BCF    03.5
0FB5:  CALL   000
.................... } 
0FB6:  BCF    0A.3
0FB7:  BSF    0A.4
0FB8:  GOTO   50D (RETURN)
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //Funcion de pantalla de menu                                           / 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... void menu(){ 
....................    glcd_fillScreen(OFF); 
*
0A3C:  BSF    03.5
0A3D:  CLRF   40
0A3E:  BCF    0A.3
0A3F:  BCF    03.5
0A40:  CALL   64B
0A41:  BSF    0A.3
....................    glcd_text57(15,5,Titulo,1,on) ; 
0A42:  MOVLW  0F
0A43:  BSF    03.5
0A44:  MOVWF  3F
0A45:  MOVLW  05
0A46:  MOVWF  40
0A47:  CLRF   42
0A48:  MOVLW  23
0A49:  MOVWF  41
0A4A:  MOVLW  01
0A4B:  MOVWF  43
0A4C:  MOVWF  44
0A4D:  BCF    03.5
0A4E:  CALL   000
....................    glcd_rect(0, 0, 127, 63, NO , ON ); 
0A4F:  BSF    03.5
0A50:  CLRF   3F
0A51:  CLRF   40
0A52:  MOVLW  7F
0A53:  MOVWF  41
0A54:  MOVLW  3F
0A55:  MOVWF  42
0A56:  CLRF   43
0A57:  MOVLW  01
0A58:  MOVWF  44
0A59:  BCF    03.5
0A5A:  CALL   1E1
....................    glcd_rect(8, 19, 118, 60, NO , ON ); 
0A5B:  MOVLW  08
0A5C:  BSF    03.5
0A5D:  MOVWF  3F
0A5E:  MOVLW  13
0A5F:  MOVWF  40
0A60:  MOVLW  76
0A61:  MOVWF  41
0A62:  MOVLW  3C
0A63:  MOVWF  42
0A64:  CLRF   43
0A65:  MOVLW  01
0A66:  MOVWF  44
0A67:  BCF    03.5
0A68:  CALL   1E1
....................    glcd_rect(11, 23,60 ,35 , NO , ON );//1 LUZ 
0A69:  MOVLW  0B
0A6A:  BSF    03.5
0A6B:  MOVWF  3F
0A6C:  MOVLW  17
0A6D:  MOVWF  40
0A6E:  MOVLW  3C
0A6F:  MOVWF  41
0A70:  MOVLW  23
0A71:  MOVWF  42
0A72:  CLRF   43
0A73:  MOVLW  01
0A74:  MOVWF  44
0A75:  BCF    03.5
0A76:  CALL   1E1
....................    glcd_rect(11, 41,60 ,56 , NO , ON );//2 CORTINA 
0A77:  MOVLW  0B
0A78:  BSF    03.5
0A79:  MOVWF  3F
0A7A:  MOVLW  29
0A7B:  MOVWF  40
0A7C:  MOVLW  3C
0A7D:  MOVWF  41
0A7E:  MOVLW  38
0A7F:  MOVWF  42
0A80:  CLRF   43
0A81:  MOVLW  01
0A82:  MOVWF  44
0A83:  BCF    03.5
0A84:  CALL   1E1
....................    glcd_rect(66, 22,115 ,35 , NO , ON );//3 Auido 
0A85:  MOVLW  42
0A86:  BSF    03.5
0A87:  MOVWF  3F
0A88:  MOVLW  16
0A89:  MOVWF  40
0A8A:  MOVLW  73
0A8B:  MOVWF  41
0A8C:  MOVLW  23
0A8D:  MOVWF  42
0A8E:  CLRF   43
0A8F:  MOVLW  01
0A90:  MOVWF  44
0A91:  BCF    03.5
0A92:  CALL   1E1
....................    glcd_rect(66,42 ,115 ,56 , NO , ON );//4 PENDIENTE 
0A93:  MOVLW  42
0A94:  BSF    03.5
0A95:  MOVWF  3F
0A96:  MOVLW  2A
0A97:  MOVWF  40
0A98:  MOVLW  73
0A99:  MOVWF  41
0A9A:  MOVLW  38
0A9B:  MOVWF  42
0A9C:  CLRF   43
0A9D:  MOVLW  01
0A9E:  MOVWF  44
0A9F:  BCF    03.5
0AA0:  CALL   1E1
....................    glcd_line(8,38,118,38,ON); 
0AA1:  MOVLW  08
0AA2:  BSF    03.5
0AA3:  MOVWF  4B
0AA4:  MOVLW  26
0AA5:  MOVWF  4C
0AA6:  MOVLW  76
0AA7:  MOVWF  4D
0AA8:  MOVLW  26
0AA9:  MOVWF  4E
0AAA:  MOVLW  01
0AAB:  MOVWF  4F
0AAC:  BCF    03.5
0AAD:  CALL   0E9
....................    glcd_line(63,19,63,60,on); 
0AAE:  MOVLW  3F
0AAF:  BSF    03.5
0AB0:  MOVWF  4B
0AB1:  MOVLW  13
0AB2:  MOVWF  4C
0AB3:  MOVLW  3F
0AB4:  MOVWF  4D
0AB5:  MOVLW  3C
0AB6:  MOVWF  4E
0AB7:  MOVLW  01
0AB8:  MOVWF  4F
0AB9:  BCF    03.5
0ABA:  CALL   0E9
....................    glcd_text57(22,25,luces,1,on) ; 
0ABB:  MOVLW  16
0ABC:  BSF    03.5
0ABD:  MOVWF  3F
0ABE:  MOVLW  19
0ABF:  MOVWF  40
0AC0:  CLRF   42
0AC1:  MOVLW  32
0AC2:  MOVWF  41
0AC3:  MOVLW  01
0AC4:  MOVWF  43
0AC5:  MOVWF  44
0AC6:  BCF    03.5
0AC7:  CALL   000
....................    glcd_text57(13,44,cortina,1,on) ; 
0AC8:  MOVLW  0D
0AC9:  BSF    03.5
0ACA:  MOVWF  3F
0ACB:  MOVLW  2C
0ACC:  MOVWF  40
0ACD:  CLRF   42
0ACE:  MOVLW  3E
0ACF:  MOVWF  41
0AD0:  MOVLW  01
0AD1:  MOVWF  43
0AD2:  MOVWF  44
0AD3:  BCF    03.5
0AD4:  CALL   000
....................    glcd_text57(76,25,audio,1,on) ; 
0AD5:  MOVLW  4C
0AD6:  BSF    03.5
0AD7:  MOVWF  3F
0AD8:  MOVLW  19
0AD9:  MOVWF  40
0ADA:  CLRF   42
0ADB:  MOVLW  38
0ADC:  MOVWF  41
0ADD:  MOVLW  01
0ADE:  MOVWF  43
0ADF:  MOVWF  44
0AE0:  BCF    03.5
0AE1:  CALL   000
.................... } 
0AE2:  RETURN
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //Funcion para chequear el touch                                        / 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... int16 getx(){ 
....................    output_high(pin_c0); 
0AE3:  BCF    22.0
0AE4:  MOVF   22,W
0AE5:  BSF    03.5
0AE6:  MOVWF  07
0AE7:  BCF    03.5
0AE8:  BSF    07.0
....................    output_low(pin_c1); 
0AE9:  BCF    22.1
0AEA:  MOVF   22,W
0AEB:  BSF    03.5
0AEC:  MOVWF  07
0AED:  BCF    03.5
0AEE:  BCF    07.1
....................    set_adc_channel(0); 
0AEF:  MOVLW  00
0AF0:  MOVWF  78
0AF1:  MOVF   1F,W
0AF2:  ANDLW  C7
0AF3:  IORWF  78,W
0AF4:  MOVWF  1F
....................    delay_ms (5); 
0AF5:  MOVLW  05
0AF6:  BSF    03.5
0AF7:  MOVWF  40
0AF8:  BCF    0A.3
0AF9:  BCF    03.5
0AFA:  CALL   70C
0AFB:  BSF    0A.3
....................    x_coord= read_adc(); // leer analogico 0 
0AFC:  BSF    1F.2
0AFD:  BTFSC  1F.2
0AFE:  GOTO   2FD
0AFF:  MOVF   1E,W
0B00:  MOVWF  7A
0B01:  BSF    03.5
0B02:  MOVF   1E,W
0B03:  MOVWF  32
0B04:  MOVF   7A,W
0B05:  MOVWF  33
....................    if(x_coord>= 512){ 
0B06:  MOVF   33,W
0B07:  SUBLW  01
0B08:  BTFSC  03.0
0B09:  GOTO   32D
....................       x_coord=x_coord - 512; 
0B0A:  MOVLW  00
0B0B:  SUBWF  32,F
0B0C:  MOVLW  02
0B0D:  BTFSS  03.0
0B0E:  MOVLW  03
0B0F:  SUBWF  33,F
....................       x_coord128=(x_coord * 128)/1024; 
0B10:  RLF    32,W
0B11:  MOVWF  3F
0B12:  RLF    33,W
0B13:  MOVWF  40
0B14:  RLF    3F,F
0B15:  RLF    40,F
0B16:  RLF    3F,F
0B17:  RLF    40,F
0B18:  RLF    3F,F
0B19:  RLF    40,F
0B1A:  RLF    3F,F
0B1B:  RLF    40,F
0B1C:  RLF    3F,F
0B1D:  RLF    40,F
0B1E:  RLF    3F,F
0B1F:  RLF    40,F
0B20:  MOVLW  80
0B21:  ANDWF  3F,F
0B22:  CLRF   37
0B23:  RRF    40,W
0B24:  MOVWF  36
0B25:  RRF    36,F
0B26:  MOVLW  3F
0B27:  ANDWF  36,F
....................       x_coord128=x_coord128 + 64; 
0B28:  MOVLW  40
0B29:  ADDWF  36,F
0B2A:  BTFSC  03.0
0B2B:  INCF   37,F
....................    }else{ 
0B2C:  GOTO   345
....................          x_coord128=((x_coord * 128 ) /1024);} 
0B2D:  RLF    32,W
0B2E:  MOVWF  3F
0B2F:  RLF    33,W
0B30:  MOVWF  40
0B31:  RLF    3F,F
0B32:  RLF    40,F
0B33:  RLF    3F,F
0B34:  RLF    40,F
0B35:  RLF    3F,F
0B36:  RLF    40,F
0B37:  RLF    3F,F
0B38:  RLF    40,F
0B39:  RLF    3F,F
0B3A:  RLF    40,F
0B3B:  RLF    3F,F
0B3C:  RLF    40,F
0B3D:  MOVLW  80
0B3E:  ANDWF  3F,F
0B3F:  CLRF   37
0B40:  RRF    40,W
0B41:  MOVWF  36
0B42:  RRF    36,F
0B43:  MOVLW  3F
0B44:  ANDWF  36,F
....................     return x_coord128; 
0B45:  MOVF   36,W
0B46:  MOVWF  78
0B47:  MOVF   37,W
0B48:  MOVWF  79
.................... } 
0B49:  BCF    03.5
0B4A:  RETURN
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //Funcion para chequear touch                                           / 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... int16 gety(){ 
....................    output_low(pin_c0); 
0B4B:  BCF    22.0
0B4C:  MOVF   22,W
0B4D:  BSF    03.5
0B4E:  MOVWF  07
0B4F:  BCF    03.5
0B50:  BCF    07.0
....................    output_high(pin_c1); 
0B51:  BCF    22.1
0B52:  MOVF   22,W
0B53:  BSF    03.5
0B54:  MOVWF  07
0B55:  BCF    03.5
0B56:  BSF    07.1
....................    set_adc_channel(1); 
0B57:  MOVLW  08
0B58:  MOVWF  78
0B59:  MOVF   1F,W
0B5A:  ANDLW  C7
0B5B:  IORWF  78,W
0B5C:  MOVWF  1F
....................    delay_ms (5); 
0B5D:  MOVLW  05
0B5E:  BSF    03.5
0B5F:  MOVWF  40
0B60:  BCF    0A.3
0B61:  BCF    03.5
0B62:  CALL   70C
0B63:  BSF    0A.3
....................    y_coord=read_adc(); // leer el analogico 1 
0B64:  BSF    1F.2
0B65:  BTFSC  1F.2
0B66:  GOTO   365
0B67:  MOVF   1E,W
0B68:  MOVWF  7A
0B69:  BSF    03.5
0B6A:  MOVF   1E,W
0B6B:  MOVWF  34
0B6C:  MOVF   7A,W
0B6D:  MOVWF  35
....................    y_coord64=64-((y_coord * 64) /1024); 
0B6E:  RLF    34,W
0B6F:  MOVWF  3F
0B70:  RLF    35,W
0B71:  MOVWF  40
0B72:  RLF    3F,F
0B73:  RLF    40,F
0B74:  RLF    3F,F
0B75:  RLF    40,F
0B76:  RLF    3F,F
0B77:  RLF    40,F
0B78:  RLF    3F,F
0B79:  RLF    40,F
0B7A:  RLF    3F,F
0B7B:  RLF    40,F
0B7C:  MOVLW  C0
0B7D:  ANDWF  3F,F
0B7E:  CLRF   7A
0B7F:  RRF    40,W
0B80:  MOVWF  79
0B81:  RRF    79,F
0B82:  MOVLW  3F
0B83:  ANDWF  79,F
0B84:  MOVF   79,W
0B85:  SUBLW  40
0B86:  MOVWF  38
0B87:  CLRF   39
0B88:  MOVF   7A,W
0B89:  BTFSS  03.0
0B8A:  INCFSZ 7A,W
0B8B:  SUBWF  39,F
....................    return y_coord64; 
0B8C:  MOVF   38,W
0B8D:  MOVWF  78
0B8E:  MOVF   39,W
0B8F:  MOVWF  79
....................  
.................... } 
0B90:  BCF    03.5
0B91:  RETURN
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //Funcion para mostrar el menu de la luz                                / 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... int menuluz(){ 
....................    glcd_fillScreen(OFF); 
*
0CFE:  BSF    03.5
0CFF:  CLRF   40
0D00:  BCF    0A.3
0D01:  BCF    03.5
0D02:  CALL   64B
0D03:  BSF    0A.3
....................    glcd_rect(0, 0, 127, 63, NO , ON );//cuadro exterior 
0D04:  BSF    03.5
0D05:  CLRF   3F
0D06:  CLRF   40
0D07:  MOVLW  7F
0D08:  MOVWF  41
0D09:  MOVLW  3F
0D0A:  MOVWF  42
0D0B:  CLRF   43
0D0C:  MOVLW  01
0D0D:  MOVWF  44
0D0E:  BCF    03.5
0D0F:  CALL   1E1
....................    //glcd_rect(22, 20, 105, 35, NO , ON );//cuadro prender apagar 
....................    //glcd_line(66,20,66,35,on);//linea titulo prende apaga 
....................    glcd_text57(8,21,PUNTA,1,on);//texto punta 
0D10:  MOVLW  08
0D11:  BSF    03.5
0D12:  MOVWF  3F
0D13:  MOVLW  15
0D14:  MOVWF  40
0D15:  CLRF   42
0D16:  MOVLW  70
0D17:  MOVWF  41
0D18:  MOVLW  01
0D19:  MOVWF  43
0D1A:  MOVWF  44
0D1B:  BCF    03.5
0D1C:  CALL   000
....................    glcd_text57(48,21,centro,1,on);//texto centro 
0D1D:  MOVLW  30
0D1E:  BSF    03.5
0D1F:  MOVWF  3F
0D20:  MOVLW  15
0D21:  MOVWF  40
0D22:  CLRF   42
0D23:  MOVLW  A0
0D24:  MOVWF  41
0D25:  MOVLW  01
0D26:  MOVWF  43
0D27:  MOVWF  44
0D28:  BCF    03.5
0D29:  CALL   000
....................    glcd_text57(92,21,PUNTA,1,on);//texto punta 
0D2A:  MOVLW  5C
0D2B:  BSF    03.5
0D2C:  MOVWF  3F
0D2D:  MOVLW  15
0D2E:  MOVWF  40
0D2F:  CLRF   42
0D30:  MOVLW  70
0D31:  MOVWF  41
0D32:  MOVLW  01
0D33:  MOVWF  43
0D34:  MOVWF  44
0D35:  BCF    03.5
0D36:  CALL   000
....................    glcd_circle(21,11,8,NO,ON);// circulo lateral 
0D37:  MOVLW  15
0D38:  BSF    03.5
0D39:  MOVWF  3F
0D3A:  MOVLW  0B
0D3B:  MOVWF  40
0D3C:  MOVLW  08
0D3D:  MOVWF  41
0D3E:  CLRF   42
0D3F:  MOVLW  01
0D40:  MOVWF  43
0D41:  BCF    03.5
0D42:  CALL   3D6
....................    glcd_circle(63,11,8,NO,ON);//circulo central 
0D43:  MOVLW  3F
0D44:  BSF    03.5
0D45:  MOVWF  3F
0D46:  MOVLW  0B
0D47:  MOVWF  40
0D48:  MOVLW  08
0D49:  MOVWF  41
0D4A:  CLRF   42
0D4B:  MOVLW  01
0D4C:  MOVWF  43
0D4D:  BCF    03.5
0D4E:  CALL   3D6
....................    glcd_circle(105,11,8,NO,ON);//circulo lateral 
0D4F:  MOVLW  69
0D50:  BSF    03.5
0D51:  MOVWF  3F
0D52:  MOVLW  0B
0D53:  MOVWF  40
0D54:  MOVLW  08
0D55:  MOVWF  41
0D56:  CLRF   42
0D57:  MOVLW  01
0D58:  MOVWF  43
0D59:  BCF    03.5
0D5A:  CALL   3D6
....................    glcd_text57(36,44,todos,1,on);//texto  todos 
0D5B:  MOVLW  24
0D5C:  BSF    03.5
0D5D:  MOVWF  3F
0D5E:  MOVLW  2C
0D5F:  MOVWF  40
0D60:  CLRF   42
0D61:  MOVLW  A7
0D62:  MOVWF  41
0D63:  MOVLW  01
0D64:  MOVWF  43
0D65:  MOVWF  44
0D66:  BCF    03.5
0D67:  CALL   000
....................    glcd_rect(84, 42, 94, 53, NO , ON );//cuadro no 
0D68:  MOVLW  54
0D69:  BSF    03.5
0D6A:  MOVWF  3F
0D6B:  MOVLW  2A
0D6C:  MOVWF  40
0D6D:  MOVLW  5E
0D6E:  MOVWF  41
0D6F:  MOVLW  35
0D70:  MOVWF  42
0D71:  CLRF   43
0D72:  MOVLW  01
0D73:  MOVWF  44
0D74:  BCF    03.5
0D75:  CALL   1E1
....................    glcd_rect(97,42, 107, 53, NO , ON );//cuadro si 
0D76:  MOVLW  61
0D77:  BSF    03.5
0D78:  MOVWF  3F
0D79:  MOVLW  2A
0D7A:  MOVWF  40
0D7B:  MOVLW  6B
0D7C:  MOVWF  41
0D7D:  MOVLW  35
0D7E:  MOVWF  42
0D7F:  CLRF   43
0D80:  MOVLW  01
0D81:  MOVWF  44
0D82:  BCF    03.5
0D83:  CALL   1E1
....................    glcd_text57(70,44,sis,1,on);//texto  no 
0D84:  MOVLW  46
0D85:  BSF    03.5
0D86:  MOVWF  3F
0D87:  MOVLW  2C
0D88:  MOVWF  40
0D89:  CLRF   42
0D8A:  MOVLW  AD
0D8B:  MOVWF  41
0D8C:  MOVLW  01
0D8D:  MOVWF  43
0D8E:  MOVWF  44
0D8F:  BCF    03.5
0D90:  CALL   000
....................    glcd_text57(112,44,non,1,on);//texto  si 
0D91:  MOVLW  70
0D92:  BSF    03.5
0D93:  MOVWF  3F
0D94:  MOVLW  2C
0D95:  MOVWF  40
0D96:  CLRF   42
0D97:  MOVLW  7C
0D98:  MOVWF  41
0D99:  MOVLW  01
0D9A:  MOVWF  43
0D9B:  MOVWF  44
0D9C:  BCF    03.5
0D9D:  CALL   000
....................    glcd_text57(7,49,menu1,1,on);//texto menu 
0D9E:  MOVLW  07
0D9F:  BSF    03.5
0DA0:  MOVWF  3F
0DA1:  MOVLW  31
0DA2:  MOVWF  40
0DA3:  CLRF   42
0DA4:  MOVLW  63
0DA5:  MOVWF  41
0DA6:  MOVLW  01
0DA7:  MOVWF  43
0DA8:  MOVWF  44
0DA9:  BCF    03.5
0DAA:  CALL   000
....................    glcd_rect(4, 45, 32, 58, NO , ON );//cuadro menu 
0DAB:  MOVLW  04
0DAC:  BSF    03.5
0DAD:  MOVWF  3F
0DAE:  MOVLW  2D
0DAF:  MOVWF  40
0DB0:  MOVLW  20
0DB1:  MOVWF  41
0DB2:  MOVLW  3A
0DB3:  MOVWF  42
0DB4:  CLRF   43
0DB5:  MOVLW  01
0DB6:  MOVWF  44
0DB7:  BCF    03.5
0DB8:  CALL   1E1
....................  
....................    while(true){ 
....................       x=getx(); 
0DB9:  CALL   2E3
0DBA:  MOVF   78,W
0DBB:  BSF    03.5
0DBC:  MOVWF  30
....................       y=gety(); 
0DBD:  BCF    03.5
0DBE:  CALL   34B
0DBF:  MOVF   78,W
0DC0:  BSF    03.5
0DC1:  MOVWF  31
....................    if ( x>=13 && x<=25 && y>=6 && y<=15){ 
0DC2:  MOVF   30,W
0DC3:  SUBLW  0C
0DC4:  BTFSC  03.0
0DC5:  GOTO   603
0DC6:  MOVF   30,W
0DC7:  SUBLW  19
0DC8:  BTFSS  03.0
0DC9:  GOTO   603
0DCA:  MOVF   31,W
0DCB:  SUBLW  05
0DCC:  BTFSC  03.0
0DCD:  GOTO   603
0DCE:  MOVF   31,W
0DCF:  SUBLW  0F
0DD0:  BTFSS  03.0
0DD1:  GOTO   603
....................      output_high(pin_a2); 
0DD2:  BCF    05.2
0DD3:  BCF    03.5
0DD4:  BSF    05.2
....................      output_low(pin_a4); 
0DD5:  BSF    03.5
0DD6:  BCF    05.4
0DD7:  BCF    03.5
0DD8:  BCF    05.4
....................      output_low(pin_a5); 
0DD9:  BSF    03.5
0DDA:  BCF    05.5
0DDB:  BCF    03.5
0DDC:  BCF    05.5
....................      output_low(pin_e0); 
0DDD:  BSF    03.5
0DDE:  BCF    09.0
0DDF:  BCF    03.5
0DE0:  BCF    09.0
....................       
....................       printf("1"); 
0DE1:  MOVLW  31
0DE2:  BTFSS  0C.4
0DE3:  GOTO   5E2
0DE4:  MOVWF  19
....................       x=0; 
0DE5:  BSF    03.5
0DE6:  CLRF   30
....................       y=0; 
0DE7:  CLRF   31
....................       delay_ms (1000); 
0DE8:  MOVLW  04
0DE9:  MOVWF  3F
0DEA:  MOVLW  FA
0DEB:  MOVWF  40
0DEC:  BCF    0A.3
0DED:  BCF    03.5
0DEE:  CALL   70C
0DEF:  BSF    0A.3
0DF0:  BSF    03.5
0DF1:  DECFSZ 3F,F
0DF2:  GOTO   5EA
....................       output_low(pin_a2); 
0DF3:  BCF    05.2
0DF4:  BCF    03.5
0DF5:  BCF    05.2
....................      output_low(pin_a4); 
0DF6:  BSF    03.5
0DF7:  BCF    05.4
0DF8:  BCF    03.5
0DF9:  BCF    05.4
....................      output_low(pin_a5); 
0DFA:  BSF    03.5
0DFB:  BCF    05.5
0DFC:  BCF    03.5
0DFD:  BCF    05.5
....................      output_low(pin_e0);}//presiona lateral 1 
0DFE:  BSF    03.5
0DFF:  BCF    09.0
0E00:  BCF    03.5
0E01:  BCF    09.0
0E02:  BSF    03.5
....................        
....................    if ( x>=55 && x<=71 && y>=6 && y<=15){ 
0E03:  MOVF   30,W
0E04:  SUBLW  36
0E05:  BTFSC  03.0
0E06:  GOTO   644
0E07:  MOVF   30,W
0E08:  SUBLW  47
0E09:  BTFSS  03.0
0E0A:  GOTO   644
0E0B:  MOVF   31,W
0E0C:  SUBLW  05
0E0D:  BTFSC  03.0
0E0E:  GOTO   644
0E0F:  MOVF   31,W
0E10:  SUBLW  0F
0E11:  BTFSS  03.0
0E12:  GOTO   644
....................             output_low(pin_a2); 
0E13:  BCF    05.2
0E14:  BCF    03.5
0E15:  BCF    05.2
....................      output_high(pin_a4); 
0E16:  BSF    03.5
0E17:  BCF    05.4
0E18:  BCF    03.5
0E19:  BSF    05.4
....................      output_low(pin_a5); 
0E1A:  BSF    03.5
0E1B:  BCF    05.5
0E1C:  BCF    03.5
0E1D:  BCF    05.5
....................      output_low(pin_e0); 
0E1E:  BSF    03.5
0E1F:  BCF    09.0
0E20:  BCF    03.5
0E21:  BCF    09.0
....................       printf("2"); 
0E22:  MOVLW  32
0E23:  BTFSS  0C.4
0E24:  GOTO   623
0E25:  MOVWF  19
....................       x=0; 
0E26:  BSF    03.5
0E27:  CLRF   30
....................       y=0; 
0E28:  CLRF   31
....................       delay_ms (1000); 
0E29:  MOVLW  04
0E2A:  MOVWF  3F
0E2B:  MOVLW  FA
0E2C:  MOVWF  40
0E2D:  BCF    0A.3
0E2E:  BCF    03.5
0E2F:  CALL   70C
0E30:  BSF    0A.3
0E31:  BSF    03.5
0E32:  DECFSZ 3F,F
0E33:  GOTO   62B
....................             output_low(pin_a2); 
0E34:  BCF    05.2
0E35:  BCF    03.5
0E36:  BCF    05.2
....................      output_low(pin_a4); 
0E37:  BSF    03.5
0E38:  BCF    05.4
0E39:  BCF    03.5
0E3A:  BCF    05.4
....................      output_low(pin_a5); 
0E3B:  BSF    03.5
0E3C:  BCF    05.5
0E3D:  BCF    03.5
0E3E:  BCF    05.5
....................      output_low(pin_e0);}//presiona centro 
0E3F:  BSF    03.5
0E40:  BCF    09.0
0E41:  BCF    03.5
0E42:  BCF    09.0
0E43:  BSF    03.5
....................  
....................    if ( x>=87 && x<=113 && y>=6 && y<=15){ 
0E44:  MOVF   30,W
0E45:  SUBLW  56
0E46:  BTFSC  03.0
0E47:  GOTO   690
0E48:  MOVF   30,W
0E49:  SUBLW  71
0E4A:  BTFSS  03.0
0E4B:  GOTO   690
0E4C:  MOVF   31,W
0E4D:  SUBLW  05
0E4E:  BTFSC  03.0
0E4F:  GOTO   690
0E50:  MOVF   31,W
0E51:  SUBLW  0F
0E52:  BTFSS  03.0
0E53:  GOTO   690
....................       output_high(pin_a2); 
0E54:  BCF    05.2
0E55:  BCF    03.5
0E56:  BSF    05.2
....................      output_high(pin_a4); 
0E57:  BSF    03.5
0E58:  BCF    05.4
0E59:  BCF    03.5
0E5A:  BSF    05.4
....................      output_low(pin_a5); 
0E5B:  BSF    03.5
0E5C:  BCF    05.5
0E5D:  BCF    03.5
0E5E:  BCF    05.5
....................      output_low(pin_e0);       
0E5F:  BSF    03.5
0E60:  BCF    09.0
0E61:  BCF    03.5
0E62:  BCF    09.0
....................       printf("3"); 
0E63:  MOVLW  33
0E64:  BTFSS  0C.4
0E65:  GOTO   664
0E66:  MOVWF  19
....................       delay_ms (1000); 
0E67:  MOVLW  04
0E68:  BSF    03.5
0E69:  MOVWF  3F
0E6A:  MOVLW  FA
0E6B:  MOVWF  40
0E6C:  BCF    0A.3
0E6D:  BCF    03.5
0E6E:  CALL   70C
0E6F:  BSF    0A.3
0E70:  BSF    03.5
0E71:  DECFSZ 3F,F
0E72:  GOTO   66A
....................       x=0; 
0E73:  CLRF   30
....................       y=0; 
0E74:  CLRF   31
....................       delay_ms (1000); 
0E75:  MOVLW  04
0E76:  MOVWF  3F
0E77:  MOVLW  FA
0E78:  MOVWF  40
0E79:  BCF    0A.3
0E7A:  BCF    03.5
0E7B:  CALL   70C
0E7C:  BSF    0A.3
0E7D:  BSF    03.5
0E7E:  DECFSZ 3F,F
0E7F:  GOTO   677
....................       output_low(pin_a2); 
0E80:  BCF    05.2
0E81:  BCF    03.5
0E82:  BCF    05.2
....................      output_low(pin_a4); 
0E83:  BSF    03.5
0E84:  BCF    05.4
0E85:  BCF    03.5
0E86:  BCF    05.4
....................      output_low(pin_a5); 
0E87:  BSF    03.5
0E88:  BCF    05.5
0E89:  BCF    03.5
0E8A:  BCF    05.5
....................      output_low(pin_e0);      }//presiona lateral 2 
0E8B:  BSF    03.5
0E8C:  BCF    09.0
0E8D:  BCF    03.5
0E8E:  BCF    09.0
0E8F:  BSF    03.5
....................    if ( x>=97 && x<=107 && y>=42 && y<=53){ 
0E90:  MOVF   30,W
0E91:  SUBLW  60
0E92:  BTFSC  03.0
0E93:  GOTO   6D1
0E94:  MOVF   30,W
0E95:  SUBLW  6B
0E96:  BTFSS  03.0
0E97:  GOTO   6D1
0E98:  MOVF   31,W
0E99:  SUBLW  29
0E9A:  BTFSC  03.0
0E9B:  GOTO   6D1
0E9C:  MOVF   31,W
0E9D:  SUBLW  35
0E9E:  BTFSS  03.0
0E9F:  GOTO   6D1
....................       output_low(pin_a2); 
0EA0:  BCF    05.2
0EA1:  BCF    03.5
0EA2:  BCF    05.2
....................      output_low(pin_a4); 
0EA3:  BSF    03.5
0EA4:  BCF    05.4
0EA5:  BCF    03.5
0EA6:  BCF    05.4
....................      output_high(pin_a5); 
0EA7:  BSF    03.5
0EA8:  BCF    05.5
0EA9:  BCF    03.5
0EAA:  BSF    05.5
....................      output_low(pin_e0);      
0EAB:  BSF    03.5
0EAC:  BCF    09.0
0EAD:  BCF    03.5
0EAE:  BCF    09.0
....................      printf("4"); 
0EAF:  MOVLW  34
0EB0:  BTFSS  0C.4
0EB1:  GOTO   6B0
0EB2:  MOVWF  19
....................       x=0; 
0EB3:  BSF    03.5
0EB4:  CLRF   30
....................       y=0; 
0EB5:  CLRF   31
....................       delay_ms (1000); 
0EB6:  MOVLW  04
0EB7:  MOVWF  3F
0EB8:  MOVLW  FA
0EB9:  MOVWF  40
0EBA:  BCF    0A.3
0EBB:  BCF    03.5
0EBC:  CALL   70C
0EBD:  BSF    0A.3
0EBE:  BSF    03.5
0EBF:  DECFSZ 3F,F
0EC0:  GOTO   6B8
....................             output_low(pin_a2); 
0EC1:  BCF    05.2
0EC2:  BCF    03.5
0EC3:  BCF    05.2
....................      output_low(pin_a4); 
0EC4:  BSF    03.5
0EC5:  BCF    05.4
0EC6:  BCF    03.5
0EC7:  BCF    05.4
....................      output_low(pin_a5); 
0EC8:  BSF    03.5
0EC9:  BCF    05.5
0ECA:  BCF    03.5
0ECB:  BCF    05.5
....................      output_low(pin_e0); 
0ECC:  BSF    03.5
0ECD:  BCF    09.0
0ECE:  BCF    03.5
0ECF:  BCF    09.0
0ED0:  BSF    03.5
....................       }//presiona no 
....................    if ( x>=66 && x<=80 && y>=42 && y<=53){ 
0ED1:  MOVF   30,W
0ED2:  SUBLW  41
0ED3:  BTFSC  03.0
0ED4:  GOTO   712
0ED5:  MOVF   30,W
0ED6:  SUBLW  50
0ED7:  BTFSS  03.0
0ED8:  GOTO   712
0ED9:  MOVF   31,W
0EDA:  SUBLW  29
0EDB:  BTFSC  03.0
0EDC:  GOTO   712
0EDD:  MOVF   31,W
0EDE:  SUBLW  35
0EDF:  BTFSS  03.0
0EE0:  GOTO   712
....................             output_high(pin_a2); 
0EE1:  BCF    05.2
0EE2:  BCF    03.5
0EE3:  BSF    05.2
....................      output_low(pin_a4); 
0EE4:  BSF    03.5
0EE5:  BCF    05.4
0EE6:  BCF    03.5
0EE7:  BCF    05.4
....................      output_high(pin_a5); 
0EE8:  BSF    03.5
0EE9:  BCF    05.5
0EEA:  BCF    03.5
0EEB:  BSF    05.5
....................      output_low(pin_e0); 
0EEC:  BSF    03.5
0EED:  BCF    09.0
0EEE:  BCF    03.5
0EEF:  BCF    09.0
....................       printf("5"); 
0EF0:  MOVLW  35
0EF1:  BTFSS  0C.4
0EF2:  GOTO   6F1
0EF3:  MOVWF  19
....................       x=0; 
0EF4:  BSF    03.5
0EF5:  CLRF   30
....................       y=0; 
0EF6:  CLRF   31
....................       delay_ms (1000); 
0EF7:  MOVLW  04
0EF8:  MOVWF  3F
0EF9:  MOVLW  FA
0EFA:  MOVWF  40
0EFB:  BCF    0A.3
0EFC:  BCF    03.5
0EFD:  CALL   70C
0EFE:  BSF    0A.3
0EFF:  BSF    03.5
0F00:  DECFSZ 3F,F
0F01:  GOTO   6F9
....................             output_low(pin_a2); 
0F02:  BCF    05.2
0F03:  BCF    03.5
0F04:  BCF    05.2
....................      output_low(pin_a4); 
0F05:  BSF    03.5
0F06:  BCF    05.4
0F07:  BCF    03.5
0F08:  BCF    05.4
....................      output_low(pin_a5); 
0F09:  BSF    03.5
0F0A:  BCF    05.5
0F0B:  BCF    03.5
0F0C:  BCF    05.5
....................      output_low(pin_e0);}//presiona si 
0F0D:  BSF    03.5
0F0E:  BCF    09.0
0F0F:  BCF    03.5
0F10:  BCF    09.0
0F11:  BSF    03.5
....................    if ( x>=4 && x<=20 && y>=50 && y<=58){ 
0F12:  MOVF   30,W
0F13:  SUBLW  03
0F14:  BTFSC  03.0
0F15:  GOTO   72A
0F16:  MOVF   30,W
0F17:  SUBLW  14
0F18:  BTFSS  03.0
0F19:  GOTO   72A
0F1A:  MOVF   31,W
0F1B:  SUBLW  31
0F1C:  BTFSC  03.0
0F1D:  GOTO   72A
0F1E:  MOVF   31,W
0F1F:  SUBLW  3A
0F20:  BTFSS  03.0
0F21:  GOTO   72A
....................       menu(); 
0F22:  BCF    03.5
0F23:  CALL   23C
....................       x=0; 
0F24:  BSF    03.5
0F25:  CLRF   30
....................       y=0; 
0F26:  CLRF   31
....................    return 1;} 
0F27:  MOVLW  01
0F28:  MOVWF  78
0F29:  GOTO   72D
.................... }//presiona menu 
0F2A:  BCF    03.5
0F2B:  GOTO   5B9
0F2C:  BSF    03.5
.................... } 
0F2D:  BCF    03.5
0F2E:  BCF    0A.3
0F2F:  BSF    0A.4
0F30:  GOTO   4C4 (RETURN)
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Funcion para mostrar el menu audio                                   / 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... int menuaudio(){ 
....................    glcd_fillScreen(OFF); 
*
1000:  BSF    03.5
1001:  CLRF   40
1002:  BCF    0A.4
1003:  BCF    03.5
1004:  CALL   64B
1005:  BSF    0A.4
....................    glcd_rect(0, 0, 127, 63, NO , ON );//cuadro exterior 
1006:  BSF    03.5
1007:  CLRF   3F
1008:  CLRF   40
1009:  MOVLW  7F
100A:  MOVWF  41
100B:  MOVLW  3F
100C:  MOVWF  42
100D:  CLRF   43
100E:  MOVLW  01
100F:  MOVWF  44
1010:  BCF    0A.4
1011:  BSF    0A.3
1012:  BCF    03.5
1013:  CALL   1E1
1014:  BSF    0A.4
1015:  BCF    0A.3
....................    glcd_rect(22, 20, 105, 35, NO , ON );//cuadro prender apagar 
1016:  MOVLW  16
1017:  BSF    03.5
1018:  MOVWF  3F
1019:  MOVLW  14
101A:  MOVWF  40
101B:  MOVLW  69
101C:  MOVWF  41
101D:  MOVLW  23
101E:  MOVWF  42
101F:  CLRF   43
1020:  MOVLW  01
1021:  MOVWF  44
1022:  BCF    0A.4
1023:  BSF    0A.3
1024:  BCF    03.5
1025:  CALL   1E1
1026:  BSF    0A.4
1027:  BCF    0A.3
....................    glcd_line(66,20,66,35,on);//linea titulo prende apaga 
1028:  MOVLW  42
1029:  BSF    03.5
102A:  MOVWF  4B
102B:  MOVLW  14
102C:  MOVWF  4C
102D:  MOVLW  42
102E:  MOVWF  4D
102F:  MOVLW  23
1030:  MOVWF  4E
1031:  MOVLW  01
1032:  MOVWF  4F
1033:  BCF    0A.4
1034:  BSF    0A.3
1035:  BCF    03.5
1036:  CALL   0E9
1037:  BSF    0A.4
1038:  BCF    0A.3
....................    glcd_line(29,15,98,15,on);//linea titulo ampli 
1039:  MOVLW  1D
103A:  BSF    03.5
103B:  MOVWF  4B
103C:  MOVLW  0F
103D:  MOVWF  4C
103E:  MOVLW  62
103F:  MOVWF  4D
1040:  MOVLW  0F
1041:  MOVWF  4E
1042:  MOVLW  01
1043:  MOVWF  4F
1044:  BCF    0A.4
1045:  BSF    0A.3
1046:  BCF    03.5
1047:  CALL   0E9
1048:  BSF    0A.4
1049:  BCF    0A.3
....................    glcd_rect(4, 45, 32, 58, NO , ON );//cuadro menu 
104A:  MOVLW  04
104B:  BSF    03.5
104C:  MOVWF  3F
104D:  MOVLW  2D
104E:  MOVWF  40
104F:  MOVLW  20
1050:  MOVWF  41
1051:  MOVLW  3A
1052:  MOVWF  42
1053:  CLRF   43
1054:  MOVLW  01
1055:  MOVWF  44
1056:  BCF    0A.4
1057:  BSF    0A.3
1058:  BCF    03.5
1059:  CALL   1E1
105A:  BSF    0A.4
105B:  BCF    0A.3
....................    glcd_rect(89, 42, 101, 53, NO , ON );//cuadro volumen menos 
105C:  MOVLW  59
105D:  BSF    03.5
105E:  MOVWF  3F
105F:  MOVLW  2A
1060:  MOVWF  40
1061:  MOVLW  65
1062:  MOVWF  41
1063:  MOVLW  35
1064:  MOVWF  42
1065:  CLRF   43
1066:  MOVLW  01
1067:  MOVWF  44
1068:  BCF    0A.4
1069:  BSF    0A.3
106A:  BCF    03.5
106B:  CALL   1E1
106C:  BSF    0A.4
106D:  BCF    0A.3
....................    glcd_rect(107,42, 119, 53, NO , ON );//cuadro volmen mas 
106E:  MOVLW  6B
106F:  BSF    03.5
1070:  MOVWF  3F
1071:  MOVLW  2A
1072:  MOVWF  40
1073:  MOVLW  77
1074:  MOVWF  41
1075:  MOVLW  35
1076:  MOVWF  42
1077:  CLRF   43
1078:  MOVLW  01
1079:  MOVWF  44
107A:  BCF    0A.4
107B:  BSF    0A.3
107C:  BCF    03.5
107D:  CALL   1E1
107E:  BSF    0A.4
107F:  BCF    0A.3
....................    glcd_text57(29,6,ampli,1,on);//texto ampli 
1080:  MOVLW  1D
1081:  BSF    03.5
1082:  MOVWF  3F
1083:  MOVLW  06
1084:  MOVWF  40
1085:  CLRF   42
1086:  MOVLW  47
1087:  MOVWF  41
1088:  MOVLW  01
1089:  MOVWF  43
108A:  MOVWF  44
108B:  BCF    0A.4
108C:  BSF    0A.3
108D:  BCF    03.5
108E:  CALL   000
108F:  BSF    0A.4
1090:  BCF    0A.3
....................    glcd_text57(24,24,prende,1,on);//texto prende 
1091:  MOVLW  18
1092:  BSF    03.5
1093:  MOVWF  3F
1094:  MOVWF  40
1095:  CLRF   42
1096:  MOVLW  54
1097:  MOVWF  41
1098:  MOVLW  01
1099:  MOVWF  43
109A:  MOVWF  44
109B:  BCF    0A.4
109C:  BSF    0A.3
109D:  BCF    03.5
109E:  CALL   000
109F:  BSF    0A.4
10A0:  BCF    0A.3
....................    glcd_text57(68,24,apaga,1,on);//texto apaga 
10A1:  MOVLW  44
10A2:  BSF    03.5
10A3:  MOVWF  3F
10A4:  MOVLW  18
10A5:  MOVWF  40
10A6:  CLRF   42
10A7:  MOVLW  5C
10A8:  MOVWF  41
10A9:  MOVLW  01
10AA:  MOVWF  43
10AB:  MOVWF  44
10AC:  BCF    0A.4
10AD:  BSF    0A.3
10AE:  BCF    03.5
10AF:  CALL   000
10B0:  BSF    0A.4
10B1:  BCF    0A.3
....................    glcd_text57(7,49,menu1,1,on);//texto menu 
10B2:  MOVLW  07
10B3:  BSF    03.5
10B4:  MOVWF  3F
10B5:  MOVLW  31
10B6:  MOVWF  40
10B7:  CLRF   42
10B8:  MOVLW  63
10B9:  MOVWF  41
10BA:  MOVLW  01
10BB:  MOVWF  43
10BC:  MOVWF  44
10BD:  BCF    0A.4
10BE:  BSF    0A.3
10BF:  BCF    03.5
10C0:  CALL   000
10C1:  BSF    0A.4
10C2:  BCF    0A.3
....................    glcd_text57(41,44,volumen,1,on);//texto volumen 
10C3:  MOVLW  29
10C4:  BSF    03.5
10C5:  MOVWF  3F
10C6:  MOVLW  2C
10C7:  MOVWF  40
10C8:  CLRF   42
10C9:  MOVLW  68
10CA:  MOVWF  41
10CB:  MOVLW  01
10CC:  MOVWF  43
10CD:  MOVWF  44
10CE:  BCF    0A.4
10CF:  BSF    0A.3
10D0:  BCF    03.5
10D1:  CALL   000
10D2:  BSF    0A.4
10D3:  BCF    0A.3
....................    glcd_line(92,48,97,48,on);//linea - 
10D4:  MOVLW  5C
10D5:  BSF    03.5
10D6:  MOVWF  4B
10D7:  MOVLW  30
10D8:  MOVWF  4C
10D9:  MOVLW  61
10DA:  MOVWF  4D
10DB:  MOVLW  30
10DC:  MOVWF  4E
10DD:  MOVLW  01
10DE:  MOVWF  4F
10DF:  BCF    0A.4
10E0:  BSF    0A.3
10E1:  BCF    03.5
10E2:  CALL   0E9
10E3:  BSF    0A.4
10E4:  BCF    0A.3
....................    glcd_line(110,48,116,48,on);//linea + 
10E5:  MOVLW  6E
10E6:  BSF    03.5
10E7:  MOVWF  4B
10E8:  MOVLW  30
10E9:  MOVWF  4C
10EA:  MOVLW  74
10EB:  MOVWF  4D
10EC:  MOVLW  30
10ED:  MOVWF  4E
10EE:  MOVLW  01
10EF:  MOVWF  4F
10F0:  BCF    0A.4
10F1:  BSF    0A.3
10F2:  BCF    03.5
10F3:  CALL   0E9
10F4:  BSF    0A.4
10F5:  BCF    0A.3
....................    glcd_line(113,45,113,51,on);//linea + 
10F6:  MOVLW  71
10F7:  BSF    03.5
10F8:  MOVWF  4B
10F9:  MOVLW  2D
10FA:  MOVWF  4C
10FB:  MOVLW  71
10FC:  MOVWF  4D
10FD:  MOVLW  33
10FE:  MOVWF  4E
10FF:  MOVLW  01
1100:  MOVWF  4F
1101:  BCF    0A.4
1102:  BSF    0A.3
1103:  BCF    03.5
1104:  CALL   0E9
1105:  BSF    0A.4
1106:  BCF    0A.3
....................    while(true){ 
....................     x=getx(); 
1107:  BCF    0A.4
1108:  BSF    0A.3
1109:  CALL   2E3
110A:  BSF    0A.4
110B:  BCF    0A.3
110C:  MOVF   78,W
110D:  BSF    03.5
110E:  MOVWF  30
....................     y=gety(); 
110F:  BCF    0A.4
1110:  BSF    0A.3
1111:  BCF    03.5
1112:  CALL   34B
1113:  BSF    0A.4
1114:  BCF    0A.3
1115:  MOVF   78,W
1116:  BSF    03.5
1117:  MOVWF  31
....................    if (x>=20 && x<=40 && y>=18 && y<=30){ 
1118:  MOVF   30,W
1119:  SUBLW  13
111A:  BTFSC  03.0
111B:  GOTO   159
111C:  MOVF   30,W
111D:  SUBLW  28
111E:  BTFSS  03.0
111F:  GOTO   159
1120:  MOVF   31,W
1121:  SUBLW  11
1122:  BTFSC  03.0
1123:  GOTO   159
1124:  MOVF   31,W
1125:  SUBLW  1E
1126:  BTFSS  03.0
1127:  GOTO   159
....................             output_low(pin_a2); 
1128:  BCF    05.2
1129:  BCF    03.5
112A:  BCF    05.2
....................      output_high(pin_a4); 
112B:  BSF    03.5
112C:  BCF    05.4
112D:  BCF    03.5
112E:  BSF    05.4
....................      output_high(pin_a5); 
112F:  BSF    03.5
1130:  BCF    05.5
1131:  BCF    03.5
1132:  BSF    05.5
....................      output_low(pin_e0); 
1133:  BSF    03.5
1134:  BCF    09.0
1135:  BCF    03.5
1136:  BCF    09.0
....................       printf("6"); 
1137:  MOVLW  36
1138:  BTFSS  0C.4
1139:  GOTO   138
113A:  MOVWF  19
....................       x=0; 
113B:  BSF    03.5
113C:  CLRF   30
....................       y=0;   
113D:  CLRF   31
....................       delay_ms (1000); 
113E:  MOVLW  04
113F:  MOVWF  3F
1140:  MOVLW  FA
1141:  MOVWF  40
1142:  BCF    0A.4
1143:  BCF    03.5
1144:  CALL   70C
1145:  BSF    0A.4
1146:  BSF    03.5
1147:  DECFSZ 3F,F
1148:  GOTO   140
....................             output_low(pin_a2); 
1149:  BCF    05.2
114A:  BCF    03.5
114B:  BCF    05.2
....................      output_low(pin_a4); 
114C:  BSF    03.5
114D:  BCF    05.4
114E:  BCF    03.5
114F:  BCF    05.4
....................      output_low(pin_a5); 
1150:  BSF    03.5
1151:  BCF    05.5
1152:  BCF    03.5
1153:  BCF    05.5
....................      output_low(pin_e0); 
1154:  BSF    03.5
1155:  BCF    09.0
1156:  BCF    03.5
1157:  BCF    09.0
1158:  BSF    03.5
.................... }//Cuadro prender 
....................  
....................    if (x>=70 && x<=90 && y>=18 && y<=30){ 
1159:  MOVF   30,W
115A:  SUBLW  45
115B:  BTFSC  03.0
115C:  GOTO   19A
115D:  MOVF   30,W
115E:  SUBLW  5A
115F:  BTFSS  03.0
1160:  GOTO   19A
1161:  MOVF   31,W
1162:  SUBLW  11
1163:  BTFSC  03.0
1164:  GOTO   19A
1165:  MOVF   31,W
1166:  SUBLW  1E
1167:  BTFSS  03.0
1168:  GOTO   19A
....................             output_high(pin_a2); 
1169:  BCF    05.2
116A:  BCF    03.5
116B:  BSF    05.2
....................      output_high(pin_a4); 
116C:  BSF    03.5
116D:  BCF    05.4
116E:  BCF    03.5
116F:  BSF    05.4
....................      output_high(pin_a5); 
1170:  BSF    03.5
1171:  BCF    05.5
1172:  BCF    03.5
1173:  BSF    05.5
....................      output_low(pin_e0); 
1174:  BSF    03.5
1175:  BCF    09.0
1176:  BCF    03.5
1177:  BCF    09.0
....................       printf("7"); 
1178:  MOVLW  37
1179:  BTFSS  0C.4
117A:  GOTO   179
117B:  MOVWF  19
....................       x=0; 
117C:  BSF    03.5
117D:  CLRF   30
....................       y=0; 
117E:  CLRF   31
....................       delay_ms (1000); 
117F:  MOVLW  04
1180:  MOVWF  3F
1181:  MOVLW  FA
1182:  MOVWF  40
1183:  BCF    0A.4
1184:  BCF    03.5
1185:  CALL   70C
1186:  BSF    0A.4
1187:  BSF    03.5
1188:  DECFSZ 3F,F
1189:  GOTO   181
....................             output_low(pin_a2); 
118A:  BCF    05.2
118B:  BCF    03.5
118C:  BCF    05.2
....................      output_low(pin_a4); 
118D:  BSF    03.5
118E:  BCF    05.4
118F:  BCF    03.5
1190:  BCF    05.4
....................      output_low(pin_a5); 
1191:  BSF    03.5
1192:  BCF    05.5
1193:  BCF    03.5
1194:  BCF    05.5
....................      output_low(pin_e0); 
1195:  BSF    03.5
1196:  BCF    09.0
1197:  BCF    03.5
1198:  BCF    09.0
1199:  BSF    03.5
.................... }//cuadro apagar 
....................  
....................    if (x>=66 && x<=85 && y>=42 && y<=53){ 
119A:  MOVF   30,W
119B:  SUBLW  41
119C:  BTFSC  03.0
119D:  GOTO   1DB
119E:  MOVF   30,W
119F:  SUBLW  55
11A0:  BTFSS  03.0
11A1:  GOTO   1DB
11A2:  MOVF   31,W
11A3:  SUBLW  29
11A4:  BTFSC  03.0
11A5:  GOTO   1DB
11A6:  MOVF   31,W
11A7:  SUBLW  35
11A8:  BTFSS  03.0
11A9:  GOTO   1DB
....................             output_low(pin_a2); 
11AA:  BCF    05.2
11AB:  BCF    03.5
11AC:  BCF    05.2
....................      output_low(pin_a4); 
11AD:  BSF    03.5
11AE:  BCF    05.4
11AF:  BCF    03.5
11B0:  BCF    05.4
....................      output_low(pin_a5); 
11B1:  BSF    03.5
11B2:  BCF    05.5
11B3:  BCF    03.5
11B4:  BCF    05.5
....................      output_high(pin_e0); 
11B5:  BSF    03.5
11B6:  BCF    09.0
11B7:  BCF    03.5
11B8:  BSF    09.0
....................       printf("8"); 
11B9:  MOVLW  38
11BA:  BTFSS  0C.4
11BB:  GOTO   1BA
11BC:  MOVWF  19
....................       x=0; 
11BD:  BSF    03.5
11BE:  CLRF   30
....................       y=0; 
11BF:  CLRF   31
....................       delay_ms (1000); 
11C0:  MOVLW  04
11C1:  MOVWF  3F
11C2:  MOVLW  FA
11C3:  MOVWF  40
11C4:  BCF    0A.4
11C5:  BCF    03.5
11C6:  CALL   70C
11C7:  BSF    0A.4
11C8:  BSF    03.5
11C9:  DECFSZ 3F,F
11CA:  GOTO   1C2
....................             output_low(pin_a2); 
11CB:  BCF    05.2
11CC:  BCF    03.5
11CD:  BCF    05.2
....................      output_low(pin_a4); 
11CE:  BSF    03.5
11CF:  BCF    05.4
11D0:  BCF    03.5
11D1:  BCF    05.4
....................      output_low(pin_a5); 
11D2:  BSF    03.5
11D3:  BCF    05.5
11D4:  BCF    03.5
11D5:  BCF    05.5
....................      output_low(pin_e0); 
11D6:  BSF    03.5
11D7:  BCF    09.0
11D8:  BCF    03.5
11D9:  BCF    09.0
11DA:  BSF    03.5
.................... }// cuadro volumen menos 
....................    if (x>=97 && x<=107 && y>=42 && y<=53){ 
11DB:  MOVF   30,W
11DC:  SUBLW  60
11DD:  BTFSC  03.0
11DE:  GOTO   21C
11DF:  MOVF   30,W
11E0:  SUBLW  6B
11E1:  BTFSS  03.0
11E2:  GOTO   21C
11E3:  MOVF   31,W
11E4:  SUBLW  29
11E5:  BTFSC  03.0
11E6:  GOTO   21C
11E7:  MOVF   31,W
11E8:  SUBLW  35
11E9:  BTFSS  03.0
11EA:  GOTO   21C
....................             output_high(pin_a2); 
11EB:  BCF    05.2
11EC:  BCF    03.5
11ED:  BSF    05.2
....................      output_low(pin_a4); 
11EE:  BSF    03.5
11EF:  BCF    05.4
11F0:  BCF    03.5
11F1:  BCF    05.4
....................      output_low(pin_a5); 
11F2:  BSF    03.5
11F3:  BCF    05.5
11F4:  BCF    03.5
11F5:  BCF    05.5
....................      output_high(pin_e0); 
11F6:  BSF    03.5
11F7:  BCF    09.0
11F8:  BCF    03.5
11F9:  BSF    09.0
....................       printf("9"); 
11FA:  MOVLW  39
11FB:  BTFSS  0C.4
11FC:  GOTO   1FB
11FD:  MOVWF  19
....................       x=0; 
11FE:  BSF    03.5
11FF:  CLRF   30
....................       y=0; 
1200:  CLRF   31
....................       delay_ms (1000); 
1201:  MOVLW  04
1202:  MOVWF  3F
1203:  MOVLW  FA
1204:  MOVWF  40
1205:  BCF    0A.4
1206:  BCF    03.5
1207:  CALL   70C
1208:  BSF    0A.4
1209:  BSF    03.5
120A:  DECFSZ 3F,F
120B:  GOTO   203
....................             output_low(pin_a2); 
120C:  BCF    05.2
120D:  BCF    03.5
120E:  BCF    05.2
....................      output_low(pin_a4); 
120F:  BSF    03.5
1210:  BCF    05.4
1211:  BCF    03.5
1212:  BCF    05.4
....................      output_low(pin_a5); 
1213:  BSF    03.5
1214:  BCF    05.5
1215:  BCF    03.5
1216:  BCF    05.5
....................      output_low(pin_e0); 
1217:  BSF    03.5
1218:  BCF    09.0
1219:  BCF    03.5
121A:  BCF    09.0
121B:  BSF    03.5
.................... }// cuadro volumen mas 
....................    if (x>=4 && x<=15 && y>=50 && y<=58){ 
121C:  MOVF   30,W
121D:  SUBLW  03
121E:  BTFSC  03.0
121F:  GOTO   236
1220:  MOVF   30,W
1221:  SUBLW  0F
1222:  BTFSS  03.0
1223:  GOTO   236
1224:  MOVF   31,W
1225:  SUBLW  31
1226:  BTFSC  03.0
1227:  GOTO   236
1228:  MOVF   31,W
1229:  SUBLW  3A
122A:  BTFSS  03.0
122B:  GOTO   236
....................       menu(); 
122C:  BCF    0A.4
122D:  BSF    0A.3
122E:  BCF    03.5
122F:  CALL   23C
1230:  BSF    0A.4
1231:  BCF    0A.3
....................       return 1; 
1232:  MOVLW  01
1233:  MOVWF  78
1234:  GOTO   238
1235:  BSF    03.5
.................... } 
.................... }//presiona menu 
1236:  BCF    03.5
1237:  GOTO   107
.................... } 
1238:  BCF    0A.3
1239:  BSF    0A.4
123A:  GOTO   4EB (RETURN)
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // Funcion par mostrar el menu de cotina                                / 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... int menucortinas() 
....................    {glcd_fillScreen(OFF); 
123B:  BSF    03.5
123C:  CLRF   40
123D:  BCF    0A.4
123E:  BCF    03.5
123F:  CALL   64B
1240:  BSF    0A.4
....................     glcd_rect(0, 0, 127, 63, NO , ON );//cuadro exterior 
1241:  BSF    03.5
1242:  CLRF   3F
1243:  CLRF   40
1244:  MOVLW  7F
1245:  MOVWF  41
1246:  MOVLW  3F
1247:  MOVWF  42
1248:  CLRF   43
1249:  MOVLW  01
124A:  MOVWF  44
124B:  BCF    0A.4
124C:  BSF    0A.3
124D:  BCF    03.5
124E:  CALL   1E1
124F:  BSF    0A.4
1250:  BCF    0A.3
....................     glcd_text57(7,49,menu1,1,on);//texto menu 
1251:  MOVLW  07
1252:  BSF    03.5
1253:  MOVWF  3F
1254:  MOVLW  31
1255:  MOVWF  40
1256:  CLRF   42
1257:  MOVLW  63
1258:  MOVWF  41
1259:  MOVLW  01
125A:  MOVWF  43
125B:  MOVWF  44
125C:  BCF    0A.4
125D:  BSF    0A.3
125E:  BCF    03.5
125F:  CALL   000
1260:  BSF    0A.4
1261:  BCF    0A.3
....................     glcd_rect(4, 45, 32, 58, NO , ON );//cuadro menu 
1262:  MOVLW  04
1263:  BSF    03.5
1264:  MOVWF  3F
1265:  MOVLW  2D
1266:  MOVWF  40
1267:  MOVLW  20
1268:  MOVWF  41
1269:  MOVLW  3A
126A:  MOVWF  42
126B:  CLRF   43
126C:  MOVLW  01
126D:  MOVWF  44
126E:  BCF    0A.4
126F:  BSF    0A.3
1270:  BCF    03.5
1271:  CALL   1E1
1272:  BSF    0A.4
1273:  BCF    0A.3
....................  
....................     while(true){ 
....................       x=getx(); 
1274:  BCF    0A.4
1275:  BSF    0A.3
1276:  CALL   2E3
1277:  BSF    0A.4
1278:  BCF    0A.3
1279:  MOVF   78,W
127A:  BSF    03.5
127B:  MOVWF  30
....................       y=gety(); 
127C:  BCF    0A.4
127D:  BSF    0A.3
127E:  BCF    03.5
127F:  CALL   34B
1280:  BSF    0A.4
1281:  BCF    0A.3
1282:  MOVF   78,W
1283:  BSF    03.5
1284:  MOVWF  31
....................    if ( x>=4 && x<=20 && y>=51 && y<=58){ 
1285:  MOVF   30,W
1286:  SUBLW  03
1287:  BTFSC  03.0
1288:  GOTO   29F
1289:  MOVF   30,W
128A:  SUBLW  14
128B:  BTFSS  03.0
128C:  GOTO   29F
128D:  MOVF   31,W
128E:  SUBLW  32
128F:  BTFSC  03.0
1290:  GOTO   29F
1291:  MOVF   31,W
1292:  SUBLW  3A
1293:  BTFSS  03.0
1294:  GOTO   29F
....................       menu(); 
1295:  BCF    0A.4
1296:  BSF    0A.3
1297:  BCF    03.5
1298:  CALL   23C
1299:  BSF    0A.4
129A:  BCF    0A.3
....................    return 1; 
129B:  MOVLW  01
129C:  MOVWF  78
129D:  GOTO   2A1
129E:  BSF    03.5
.................... }//presiona menu 
.................... }} 
129F:  BCF    03.5
12A0:  GOTO   274
12A1:  BCF    0A.3
12A2:  BSF    0A.4
12A3:  GOTO   510 (RETURN)
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //Funcion para ver si solto el touch                                    / 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... void solto(){ 
....................    i=0; 
....................    while(i==1) 
....................       {x=getx(); 
....................       y=gety(); 
....................    if (x>1 && x<125 && y>2 && y<62){ 
....................       i=0;} 
....................     else{i=1;} 
.................... } 
.................... } 
....................  

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
