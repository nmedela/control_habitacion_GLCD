CCS PCM C Compiler, Version 4.114, 93460303               19-may-16 11:15

               Filename: C:\Users\Nico\Documents\carpetas\Programa para glcd\Central para GLCD.lst

               ROM used: 1127 words (14%)
                         Largest free fragment is 2048
               RAM used: 21 (6%) at main() level
                         42 (11%) worst case
               Stack:    5 worst case (2 in main + 3 for interrupts)

*
0000:  MOVLW  03
0001:  MOVWF  0A
0002:  GOTO   3BD
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  MOVLW  8C
0018:  MOVWF  04
0019:  BTFSS  00.5
001A:  GOTO   01D
001B:  BTFSC  0C.5
001C:  GOTO   032
001D:  BTFSS  0B.5
001E:  GOTO   021
001F:  BTFSC  0B.2
0020:  GOTO   035
0021:  MOVF   22,W
0022:  MOVWF  04
0023:  MOVF   23,W
0024:  MOVWF  77
0025:  MOVF   24,W
0026:  MOVWF  78
0027:  MOVF   25,W
0028:  MOVWF  79
0029:  MOVF   26,W
002A:  MOVWF  7A
002B:  MOVF   20,W
002C:  MOVWF  0A
002D:  SWAPF  21,W
002E:  MOVWF  03
002F:  SWAPF  7F,F
0030:  SWAPF  7F,W
0031:  RETFIE
0032:  BCF    0A.3
0033:  BCF    0A.4
0034:  GOTO   205
0035:  BCF    0A.3
0036:  BCF    0A.4
0037:  GOTO   275
.................... /////////////////////////////////////////// 
.................... //PUERTO B CONTROL DE COSAS 
.................... //A0 toma de LM35 
.................... //C6 y 77 para rs232 
.................... //a1 a2 a3 a4 recibe rf 
.................... // 
.................... // 
.................... // 
.................... //////////////////////////////////////////// 
....................  
....................  
.................... #include <16f877a.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #device ADC=10; 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
03D5:  BCF    03.5
03D6:  CLRF   28
03D7:  CLRF   29
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <STRING.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #use delay (clock=4000000) 
*
0089:  MOVLW  39
008A:  MOVWF  04
008B:  BCF    03.7
008C:  MOVF   00,W
008D:  BTFSC  03.2
008E:  GOTO   09D
008F:  MOVLW  01
0090:  MOVWF  78
0091:  CLRF   77
0092:  DECFSZ 77,F
0093:  GOTO   092
0094:  DECFSZ 78,F
0095:  GOTO   091
0096:  MOVLW  4A
0097:  MOVWF  77
0098:  DECFSZ 77,F
0099:  GOTO   098
009A:  GOTO   09B
009B:  DECFSZ 00,F
009C:  GOTO   08F
009D:  RETURN
.................... #use rs232 (baud=2400,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
.................... #fuses XT,NOWDT,PUT 
.................... #byte porta=0x05 
.................... #byte portd=0x08 
.................... #byte portb=0x06 
.................... #byte portc=0x07 
.................... #byte trisa=0x85 
.................... #byte trisd=0x88 
.................... #use fast_io(a) 
.................... #use fast_io(b) 
.................... #use fast_io(c) 
.................... #use fast_io(d) 
.................... char mensaje=""; 
.................... char datos=""; 
.................... void actuar(char mensaje, char datos); 
....................  
.................... #INT_RDA               //SERVICIO DE INTERRUPCIÓN POR RS232 
.................... void rda_isr() 
.................... { 
.................... mensaje=getch(); 
*
0205:  BTFSS  0C.5
0206:  GOTO   205
0207:  MOVF   1A,W
0208:  MOVWF  2A
....................  
.................... // PONER EN ALTO O BAJO CADA SALIDA SEGUN CORRESPONDA 
.................... actuar(mensaje,0); 
0209:  MOVF   2A,W
020A:  MOVWF  36
020B:  CLRF   37
020C:  CALL   09E
.................... mensaje=""; 
020D:  CLRF   2A
.................... } 
....................  
020E:  BCF    0C.5
020F:  BCF    0A.3
0210:  BCF    0A.4
0211:  GOTO   021
.................... void actuar( char mensaje, char datos){ 
.................... if (mensaje=='1' || datos== 0x01){ 
*
009E:  MOVF   36,W
009F:  SUBLW  31
00A0:  BTFSC  03.2
00A1:  GOTO   0A4
00A2:  DECFSZ 37,W
00A3:  GOTO   0C3
....................    printf("Presionaste el %c \r ",mensaje); 
00A4:  MOVLW  12
00A5:  BSF    03.6
00A6:  MOVWF  0D
00A7:  MOVLW  02
00A8:  MOVWF  0F
00A9:  BCF    03.0
00AA:  MOVLW  0F
00AB:  BCF    03.6
00AC:  MOVWF  38
00AD:  CALL   038
00AE:  MOVF   36,W
00AF:  BTFSS  0C.4
00B0:  GOTO   0AF
00B1:  MOVWF  19
00B2:  MOVLW  20
00B3:  BTFSS  0C.4
00B4:  GOTO   0B3
00B5:  MOVWF  19
00B6:  MOVLW  0D
00B7:  BTFSS  0C.4
00B8:  GOTO   0B7
00B9:  MOVWF  19
00BA:  MOVLW  20
00BB:  BTFSS  0C.4
00BC:  GOTO   0BB
00BD:  MOVWF  19
....................    if(bit_test(portb,0)){ 
00BE:  BTFSS  06.0
00BF:  GOTO   0C2
....................       output_low(PIN_B0); 
00C0:  BCF    06.0
....................    }else{ 
00C1:  GOTO   0C3
....................       output_high(PIN_B0);} 
00C2:  BSF    06.0
....................    }//lateral 1 
.................... if (mensaje=='2' || datos== 0x02){ 
00C3:  MOVF   36,W
00C4:  SUBLW  32
00C5:  BTFSC  03.2
00C6:  GOTO   0CB
00C7:  MOVF   37,W
00C8:  SUBLW  02
00C9:  BTFSS  03.2
00CA:  GOTO   0EA
....................    printf("Presionaste el %c \r ",mensaje); 
00CB:  MOVLW  1D
00CC:  BSF    03.6
00CD:  MOVWF  0D
00CE:  MOVLW  02
00CF:  MOVWF  0F
00D0:  BCF    03.0
00D1:  MOVLW  0F
00D2:  BCF    03.6
00D3:  MOVWF  38
00D4:  CALL   038
00D5:  MOVF   36,W
00D6:  BTFSS  0C.4
00D7:  GOTO   0D6
00D8:  MOVWF  19
00D9:  MOVLW  20
00DA:  BTFSS  0C.4
00DB:  GOTO   0DA
00DC:  MOVWF  19
00DD:  MOVLW  0D
00DE:  BTFSS  0C.4
00DF:  GOTO   0DE
00E0:  MOVWF  19
00E1:  MOVLW  20
00E2:  BTFSS  0C.4
00E3:  GOTO   0E2
00E4:  MOVWF  19
....................    if(!bit_test(portb,1)){ 
00E5:  BTFSC  06.1
00E6:  GOTO   0E9
....................       output_high(PIN_B1);}else{output_low(PIN_B1);} 
00E7:  BSF    06.1
00E8:  GOTO   0EA
00E9:  BCF    06.1
....................    }//centro 
.................... if (mensaje=='3' || datos==0x03){ 
00EA:  MOVF   36,W
00EB:  SUBLW  33
00EC:  BTFSC  03.2
00ED:  GOTO   0F2
00EE:  MOVF   37,W
00EF:  SUBLW  03
00F0:  BTFSS  03.2
00F1:  GOTO   111
....................    printf("Presionaste el  %c \r ",mensaje); 
00F2:  MOVLW  28
00F3:  BSF    03.6
00F4:  MOVWF  0D
00F5:  MOVLW  02
00F6:  MOVWF  0F
00F7:  BCF    03.0
00F8:  MOVLW  10
00F9:  BCF    03.6
00FA:  MOVWF  38
00FB:  CALL   038
00FC:  MOVF   36,W
00FD:  BTFSS  0C.4
00FE:  GOTO   0FD
00FF:  MOVWF  19
0100:  MOVLW  20
0101:  BTFSS  0C.4
0102:  GOTO   101
0103:  MOVWF  19
0104:  MOVLW  0D
0105:  BTFSS  0C.4
0106:  GOTO   105
0107:  MOVWF  19
0108:  MOVLW  20
0109:  BTFSS  0C.4
010A:  GOTO   109
010B:  MOVWF  19
....................    if(!bit_test(portb,2)){ 
010C:  BTFSC  06.2
010D:  GOTO   110
....................       output_high(PIN_B2);}else{output_low(PIN_B2);} 
010E:  BSF    06.2
010F:  GOTO   111
0110:  BCF    06.2
....................    }//lateral 2 
....................  
.................... if (mensaje=='4' || datos==0x04){ 
0111:  MOVF   36,W
0112:  SUBLW  34
0113:  BTFSC  03.2
0114:  GOTO   119
0115:  MOVF   37,W
0116:  SUBLW  04
0117:  BTFSS  03.2
0118:  GOTO   136
.................... printf("Presionaste el  %c \r ",mensaje); 
0119:  MOVLW  33
011A:  BSF    03.6
011B:  MOVWF  0D
011C:  MOVLW  02
011D:  MOVWF  0F
011E:  BCF    03.0
011F:  MOVLW  10
0120:  BCF    03.6
0121:  MOVWF  38
0122:  CALL   038
0123:  MOVF   36,W
0124:  BTFSS  0C.4
0125:  GOTO   124
0126:  MOVWF  19
0127:  MOVLW  20
0128:  BTFSS  0C.4
0129:  GOTO   128
012A:  MOVWF  19
012B:  MOVLW  0D
012C:  BTFSS  0C.4
012D:  GOTO   12C
012E:  MOVWF  19
012F:  MOVLW  20
0130:  BTFSS  0C.4
0131:  GOTO   130
0132:  MOVWF  19
.................... output_LOW(PIN_B0); 
0133:  BCF    06.0
.................... output_LOW(PIN_B1); 
0134:  BCF    06.1
.................... output_LOW(PIN_B2); 
0135:  BCF    06.2
.................... }//presiona no 
....................  
.................... if (mensaje=='5' || datos==0x05){ 
0136:  MOVF   36,W
0137:  SUBLW  35
0138:  BTFSC  03.2
0139:  GOTO   13E
013A:  MOVF   37,W
013B:  SUBLW  05
013C:  BTFSS  03.2
013D:  GOTO   15B
.................... printf("Presionaste el  %c \r ",mensaje); 
013E:  MOVLW  3E
013F:  BSF    03.6
0140:  MOVWF  0D
0141:  MOVLW  02
0142:  MOVWF  0F
0143:  BCF    03.0
0144:  MOVLW  10
0145:  BCF    03.6
0146:  MOVWF  38
0147:  CALL   038
0148:  MOVF   36,W
0149:  BTFSS  0C.4
014A:  GOTO   149
014B:  MOVWF  19
014C:  MOVLW  20
014D:  BTFSS  0C.4
014E:  GOTO   14D
014F:  MOVWF  19
0150:  MOVLW  0D
0151:  BTFSS  0C.4
0152:  GOTO   151
0153:  MOVWF  19
0154:  MOVLW  20
0155:  BTFSS  0C.4
0156:  GOTO   155
0157:  MOVWF  19
.................... output_high(PIN_B0); 
0158:  BSF    06.0
.................... output_high(PIN_B1); 
0159:  BSF    06.1
.................... output_high(PIN_B2); 
015A:  BSF    06.2
.................... }//presiona si 
....................  
.................... if (mensaje=='6' || datos==0x06){ 
015B:  MOVF   36,W
015C:  SUBLW  36
015D:  BTFSC  03.2
015E:  GOTO   163
015F:  MOVF   37,W
0160:  SUBLW  06
0161:  BTFSS  03.2
0162:  GOTO   17E
.................... printf("Presionaste el  %c \r ",mensaje); 
0163:  MOVLW  49
0164:  BSF    03.6
0165:  MOVWF  0D
0166:  MOVLW  02
0167:  MOVWF  0F
0168:  BCF    03.0
0169:  MOVLW  10
016A:  BCF    03.6
016B:  MOVWF  38
016C:  CALL   038
016D:  MOVF   36,W
016E:  BTFSS  0C.4
016F:  GOTO   16E
0170:  MOVWF  19
0171:  MOVLW  20
0172:  BTFSS  0C.4
0173:  GOTO   172
0174:  MOVWF  19
0175:  MOVLW  0D
0176:  BTFSS  0C.4
0177:  GOTO   176
0178:  MOVWF  19
0179:  MOVLW  20
017A:  BTFSS  0C.4
017B:  GOTO   17A
017C:  MOVWF  19
.................... output_high(PIN_B3); 
017D:  BSF    06.3
....................  
.................... }//presiona prender ampli 
....................  
....................  
.................... if (mensaje=='7' || datos==0x07){ 
017E:  MOVF   36,W
017F:  SUBLW  37
0180:  BTFSC  03.2
0181:  GOTO   186
0182:  MOVF   37,W
0183:  SUBLW  07
0184:  BTFSS  03.2
0185:  GOTO   1A1
.................... printf("Presionaste el  %c \r ",mensaje); 
0186:  MOVLW  54
0187:  BSF    03.6
0188:  MOVWF  0D
0189:  MOVLW  02
018A:  MOVWF  0F
018B:  BCF    03.0
018C:  MOVLW  10
018D:  BCF    03.6
018E:  MOVWF  38
018F:  CALL   038
0190:  MOVF   36,W
0191:  BTFSS  0C.4
0192:  GOTO   191
0193:  MOVWF  19
0194:  MOVLW  20
0195:  BTFSS  0C.4
0196:  GOTO   195
0197:  MOVWF  19
0198:  MOVLW  0D
0199:  BTFSS  0C.4
019A:  GOTO   199
019B:  MOVWF  19
019C:  MOVLW  20
019D:  BTFSS  0C.4
019E:  GOTO   19D
019F:  MOVWF  19
.................... output_low(PIN_B3); 
01A0:  BCF    06.3
.................... }//presiona apagar ampli 
....................  
.................... if (mensaje=='8' || datos==0x08){ 
01A1:  MOVF   36,W
01A2:  SUBLW  38
01A3:  BTFSC  03.2
01A4:  GOTO   1A9
01A5:  MOVF   37,W
01A6:  SUBLW  08
01A7:  BTFSS  03.2
01A8:  GOTO   1CC
.................... printf("Presionaste el  %c \r ",mensaje); 
01A9:  MOVLW  5F
01AA:  BSF    03.6
01AB:  MOVWF  0D
01AC:  MOVLW  02
01AD:  MOVWF  0F
01AE:  BCF    03.0
01AF:  MOVLW  10
01B0:  BCF    03.6
01B1:  MOVWF  38
01B2:  CALL   038
01B3:  MOVF   36,W
01B4:  BTFSS  0C.4
01B5:  GOTO   1B4
01B6:  MOVWF  19
01B7:  MOVLW  20
01B8:  BTFSS  0C.4
01B9:  GOTO   1B8
01BA:  MOVWF  19
01BB:  MOVLW  0D
01BC:  BTFSS  0C.4
01BD:  GOTO   1BC
01BE:  MOVWF  19
01BF:  MOVLW  20
01C0:  BTFSS  0C.4
01C1:  GOTO   1C0
01C2:  MOVWF  19
.................... output_high(PIN_B4); 
01C3:  BSF    06.4
.................... delay_ms(500); 
01C4:  MOVLW  02
01C5:  MOVWF  38
01C6:  MOVLW  FA
01C7:  MOVWF  39
01C8:  CALL   089
01C9:  DECFSZ 38,F
01CA:  GOTO   1C6
.................... output_low(PIN_B4); 
01CB:  BCF    06.4
.................... }//Volumen menos 
....................  
.................... if (mensaje=='9' || datos==0x09){ 
01CC:  MOVF   36,W
01CD:  SUBLW  39
01CE:  BTFSC  03.2
01CF:  GOTO   1D4
01D0:  MOVF   37,W
01D1:  SUBLW  09
01D2:  BTFSS  03.2
01D3:  GOTO   1F7
.................... printf("Presionaste el  %c \r ",mensaje); 
01D4:  MOVLW  6A
01D5:  BSF    03.6
01D6:  MOVWF  0D
01D7:  MOVLW  02
01D8:  MOVWF  0F
01D9:  BCF    03.0
01DA:  MOVLW  10
01DB:  BCF    03.6
01DC:  MOVWF  38
01DD:  CALL   038
01DE:  MOVF   36,W
01DF:  BTFSS  0C.4
01E0:  GOTO   1DF
01E1:  MOVWF  19
01E2:  MOVLW  20
01E3:  BTFSS  0C.4
01E4:  GOTO   1E3
01E5:  MOVWF  19
01E6:  MOVLW  0D
01E7:  BTFSS  0C.4
01E8:  GOTO   1E7
01E9:  MOVWF  19
01EA:  MOVLW  20
01EB:  BTFSS  0C.4
01EC:  GOTO   1EB
01ED:  MOVWF  19
.................... output_high(PIN_B5); 
01EE:  BSF    06.5
.................... delay_ms(500); 
01EF:  MOVLW  02
01F0:  MOVWF  38
01F1:  MOVLW  FA
01F2:  MOVWF  39
01F3:  CALL   089
01F4:  DECFSZ 38,F
01F5:  GOTO   1F1
.................... output_low(PIN_B5); 
01F6:  BCF    06.5
.................... }//volumen mas 
.................... delay_ms(500); 
01F7:  MOVLW  02
01F8:  MOVWF  38
01F9:  MOVLW  FA
01FA:  MOVWF  39
01FB:  CALL   089
01FC:  DECFSZ 38,F
01FD:  GOTO   1F9
.................... while(datos!=0){ 
01FE:  MOVF   37,F
01FF:  BTFSC  03.2
0200:  GOTO   204
.................... datos=input_a();} 
0201:  MOVF   05,W
0202:  MOVWF  37
0203:  GOTO   1FE
....................  
.................... } 
0204:  RETURN
....................  
....................  
.................... int16 medicion=0; 
.................... int8 temper=0; 
....................  
....................  
....................  
.................... void main(){ 
*
03BD:  CLRF   04
03BE:  BCF    03.7
03BF:  MOVLW  1F
03C0:  ANDWF  03,F
03C1:  MOVLW  19
03C2:  BSF    03.5
03C3:  MOVWF  19
03C4:  MOVLW  A2
03C5:  MOVWF  18
03C6:  MOVLW  90
03C7:  BCF    03.5
03C8:  MOVWF  18
03C9:  CLRF   2A
03CA:  CLRF   2B
03CB:  CLRF   2D
03CC:  CLRF   2C
03CD:  CLRF   2E
03CE:  BSF    03.5
03CF:  BSF    1F.0
03D0:  BSF    1F.1
03D1:  BSF    1F.2
03D2:  BCF    1F.3
03D3:  MOVLW  07
03D4:  MOVWF  1C
.................... int8 datos1; 
.................... enable_interrupts(INT_RDA);      //Habilita interrupción por recepción RS232 
*
03D8:  BSF    03.5
03D9:  BSF    0C.5
.................... setup_timer_0(RTCC_INTERNAL|RTCC_DIV_256); 
03DA:  MOVF   01,W
03DB:  ANDLW  C0
03DC:  IORLW  07
03DD:  MOVWF  01
.................... enable_interrupts(INT_TIMER0); 
03DE:  BCF    03.5
03DF:  BSF    0B.5
.................... enable_interrupts(GLOBAL);       //Habilita interrupcion global 
03E0:  MOVLW  C0
03E1:  IORWF  0B,F
.................... setup_adc_ports(AN0);// PUERTO A0 COMO ANAL 
03E2:  BSF    03.5
03E3:  BCF    1F.0
03E4:  BSF    1F.1
03E5:  BSF    1F.2
03E6:  BSF    1F.3
.................... setup_adc(ADC_CLOCK_INTERNAL); // configuro ADC 
03E7:  BCF    1F.6
03E8:  BCF    03.5
03E9:  BSF    1F.6
03EA:  BSF    1F.7
03EB:  BSF    03.5
03EC:  BSF    1F.7
03ED:  BCF    03.5
03EE:  BSF    1F.0
.................... set_TIMER0(50); //inicializa el timer0 
03EF:  MOVLW  32
03F0:  MOVWF  01
.................... SET_TRIS_A(0xff); 
03F1:  MOVLW  FF
03F2:  BSF    03.5
03F3:  MOVWF  05
.................... SET_TRIS_B(0x00); 
03F4:  MOVLW  00
03F5:  MOVWF  06
.................... SET_TRIS_C(0x80); 
03F6:  MOVLW  80
03F7:  MOVWF  07
.................... SET_TRIS_D(0x00); 
03F8:  MOVLW  00
03F9:  MOVWF  08
.................... SET_TRIS_E(0x0f); 
03FA:  BSF    09.0
03FB:  BSF    09.1
03FC:  BSF    09.2
.................... portb=0; 
03FD:  BCF    03.5
03FE:  CLRF   06
.................... portd=0; 
03FF:  CLRF   08
.................... portc=0; 
0400:  CLRF   07
.................... output_high(PIN_C4); 
0401:  BSF    07.4
.................... while(true){ 
.................... if(!input(PIN_E0)){ 
0402:  BSF    03.5
0403:  BSF    09.0
0404:  BCF    03.5
0405:  BTFSC  09.0
0406:  GOTO   422
0407:  CLRF   27
0408:  BTFSC  0B.7
0409:  BSF    27.7
040A:  BCF    0B.7
.................... delay_ms(60); 
040B:  MOVLW  3C
040C:  MOVWF  39
040D:  CALL   089
040E:  BTFSC  27.7
040F:  BSF    0B.7
.................... if(!input(PIN_E0)){ 
0410:  BSF    03.5
0411:  BSF    09.0
0412:  BCF    03.5
0413:  BTFSC  09.0
0414:  GOTO   422
.................... if((!bit_test(portb,0)) || (!bit_test(portb,1)) || (!bit_test(portb,2)) ){ 
0415:  BTFSS  06.0
0416:  GOTO   41B
0417:  BTFSS  06.1
0418:  GOTO   41B
0419:  BTFSC  06.2
041A:  GOTO   41F
.................... output_high(PIN_B0); 
041B:  BSF    06.0
.................... output_high(PIN_B1); 
041C:  BSF    06.1
.................... output_high(PIN_B2);}else{ 
041D:  BSF    06.2
041E:  GOTO   422
.................... output_low(PIN_B0); 
041F:  BCF    06.0
.................... output_low(PIN_B1); 
0420:  BCF    06.1
.................... output_low(PIN_B2); 
0421:  BCF    06.2
.................... } 
.................... } 
.................... } 
.................... if(!input(PIN_E1)){ 
0422:  BSF    03.5
0423:  BSF    09.1
0424:  BCF    03.5
0425:  BTFSC  09.1
0426:  GOTO   43A
0427:  CLRF   27
0428:  BTFSC  0B.7
0429:  BSF    27.7
042A:  BCF    0B.7
.................... delay_ms(50); 
042B:  MOVLW  32
042C:  MOVWF  39
042D:  CALL   089
042E:  BTFSC  27.7
042F:  BSF    0B.7
.................... if(!input(PIN_E1)){ 
0430:  BSF    03.5
0431:  BSF    09.1
0432:  BCF    03.5
0433:  BTFSC  09.1
0434:  GOTO   43A
.................... if(!bit_test(portb,3)){ 
0435:  BTFSC  06.3
0436:  GOTO   439
.................... output_high(PIN_B3);}else{ 
0437:  BSF    06.3
0438:  GOTO   43A
.................... output_low(PIN_B3); 
0439:  BCF    06.3
.................... } 
.................... } 
.................... } 
.................... while((!input(PIN_E0)) || (!input(PIN_E1))){ 
043A:  BSF    03.5
043B:  BSF    09.0
043C:  BCF    03.5
043D:  BTFSS  09.0
043E:  GOTO   443
043F:  BSF    03.5
0440:  BSF    09.1
0441:  BCF    03.5
0442:  BTFSS  09.1
.................... } 
0443:  GOTO   43A
....................  
.................... datos1=input_A(); 
0444:  MOVF   05,W
0445:  MOVWF  2F
.................... datos1=datos1>>1; 
0446:  BCF    03.0
0447:  RRF    2F,F
.................... if (datos1!=0){ 
0448:  MOVF   2F,F
0449:  BTFSC  03.2
044A:  GOTO   465
044B:  CLRF   27
044C:  BTFSC  0B.7
044D:  BSF    27.7
044E:  BCF    0B.7
.................... delay_ms(50); 
044F:  MOVLW  32
0450:  MOVWF  39
0451:  CALL   089
0452:  BTFSC  27.7
0453:  BSF    0B.7
.................... datos1=input_A(); 
0454:  MOVF   05,W
0455:  MOVWF  2F
.................... datos1=datos1>>1; 
0456:  BCF    03.0
0457:  RRF    2F,F
.................... if (datos1!=0){ 
0458:  MOVF   2F,F
0459:  BTFSC  03.2
045A:  GOTO   465
045B:  CLRF   27
045C:  BTFSC  0B.7
045D:  BSF    27.7
045E:  BCF    0B.7
.................... actuar(0,datos1); 
045F:  CLRF   36
0460:  MOVF   2F,W
0461:  MOVWF  37
0462:  CALL   09E
0463:  BTFSC  27.7
0464:  BSF    0B.7
.................... } 
.................... } 
....................  
.................... } 
0465:  GOTO   402
....................  
.................... /// FALTA PPONER LA DETECCION DE EL CODIGO DE RF!!!!!!!!!!!!!!!!!!!!!!!!!/// 
.................... } 
.................... #int_TIMER0 
.................... void  TIMER0_isr(void)  
0466:  SLEEP
.................... {int8 decimal; 
.................... int8 unidad; 
....................  
.................... output_toggle(PIN_D0); 
*
0275:  MOVLW  01
0276:  XORWF  08,F
....................  
.................... set_adc_channel (0);                // Elige canal a medir RA0 
0277:  MOVLW  00
0278:  MOVWF  78
0279:  MOVF   1F,W
027A:  ANDLW  C7
027B:  IORWF  78,W
027C:  MOVWF  1F
.................... delay_us (20); 
027D:  MOVLW  06
027E:  MOVWF  77
027F:  DECFSZ 77,F
0280:  GOTO   27F
0281:  NOP
.................... medicion=read_adc ();              // Hace conversión AD  
0282:  BSF    1F.2
0283:  BTFSC  1F.2
0284:  GOTO   283
0285:  BSF    03.5
0286:  MOVF   1E,W
0287:  BCF    03.5
0288:  MOVWF  2C
0289:  MOVF   1E,W
028A:  MOVWF  2D
.................... temper=medicion*(0.48852);     // Pasa binario a °C 
028B:  MOVF   2D,W
028C:  MOVWF  39
028D:  MOVF   2C,W
028E:  MOVWF  38
*
02AB:  MOVF   7A,W
02AC:  MOVWF  3B
02AD:  MOVF   79,W
02AE:  MOVWF  3A
02AF:  MOVF   78,W
02B0:  MOVWF  39
02B1:  MOVF   77,W
02B2:  MOVWF  38
02B3:  MOVLW  4B
02B4:  MOVWF  3F
02B5:  MOVLW  1F
02B6:  MOVWF  3E
02B7:  MOVLW  7A
02B8:  MOVWF  3D
02B9:  MOVLW  7D
02BA:  MOVWF  3C
*
032F:  MOVF   7A,W
0330:  MOVWF  3B
0331:  MOVF   79,W
0332:  MOVWF  3A
0333:  MOVF   78,W
0334:  MOVWF  39
0335:  MOVF   77,W
0336:  MOVWF  38
*
0355:  MOVF   78,W
0356:  MOVWF  2E
.................... decimal=(temper/10)& 0b00001111; 
0357:  MOVF   2E,W
0358:  MOVWF  38
0359:  MOVLW  0A
035A:  MOVWF  39
*
036F:  MOVF   78,W
0370:  ANDLW  0F
0371:  MOVWF  36
.................... unidad=((temper - (decimal*10)) & 0b00001111); 
0372:  MOVF   36,W
0373:  MOVWF  38
0374:  MOVLW  0A
0375:  MOVWF  39
*
039A:  MOVF   78,W
039B:  SUBWF  2E,W
039C:  ANDLW  0F
039D:  MOVWF  37
....................  
.................... if (bit_test(portc,4)){ 
039E:  BTFSS  07.4
039F:  GOTO   3AC
.................... output_low(PIN_C4);delay_us (20); 
03A0:  BCF    07.4
03A1:  MOVLW  06
03A2:  MOVWF  77
03A3:  DECFSZ 77,F
03A4:  GOTO   3A3
03A5:  NOP
.................... portc=portc & 0b11110000 ; 
03A6:  MOVLW  F0
03A7:  ANDWF  07,F
.................... portc=decimal | portc; 
03A8:  MOVF   36,W
03A9:  IORWF  07,F
.................... output_high(PIN_C5);}else{ 
03AA:  BSF    07.5
03AB:  GOTO   3B7
.................... output_low(PIN_C5);delay_us (20); 
03AC:  BCF    07.5
03AD:  MOVLW  06
03AE:  MOVWF  77
03AF:  DECFSZ 77,F
03B0:  GOTO   3AF
03B1:  NOP
.................... portc=portc & 0b11110000 ; 
03B2:  MOVLW  F0
03B3:  ANDWF  07,F
.................... portc=unidad | portc; 
03B4:  MOVF   37,W
03B5:  IORWF  07,F
.................... output_high(PIN_C4); 
03B6:  BSF    07.4
.................... } 
....................  
....................  
.................... set_TIMER0(217); //inicializa el timer0 
03B7:  MOVLW  D9
03B8:  MOVWF  01
.................... } 
03B9:  BCF    0B.2
03BA:  BCF    0A.3
03BB:  BCF    0A.4
03BC:  GOTO   021

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
